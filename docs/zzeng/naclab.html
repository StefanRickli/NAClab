<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns:v="urn:schemas-microsoft-com:vml" xmlns:o="urn:schemas-microsoft-com:office:office" xmlns="http://www.w3.org/TR/REC-html40"><head><!-- saved from url=(0034)http://homepages.neiu.edu/~naclab/ --><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Language" content="en-us">
<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
<meta name="ProgId" content="FrontPage.Editor.Document">


<title>NAClab</title><style>
<!--
span.SpellE
{}
span.GramE
{}
-->
</style></head>
<body>
<p>
[<a href="#download"> &nbsp;Download &nbsp; </a>]&nbsp; &nbsp;[<a href="#Table_of_contents"> Table of Contents</a> ] &nbsp; [ <a href="#Key_features:">Key features</a> &nbsp;] &nbsp;[<a href="#Relevant_publications"> <span style="text-decoration: underline;">P</span></a><a href="#Relevant_publications">ublications</a> &nbsp;] &nbsp; &nbsp;
[<a href="#Contact"> &nbsp;Contact &nbsp; </a>] &nbsp; &nbsp;[<a href="#About"> &nbsp;About &nbsp;</a>]</p><p><b><font face="Agency FB" size="7">NAClab</font></b><font size="6"> -- </font><font size="5">Numerical
Algebraic Computing Toolbox for Matlab<br></font>Copyright <b>Â©</b>
2012 by Zhonggang Zeng.&nbsp; All rights reserved.
&nbsp;Updated on August 18, 2018</p><span style="font-weight: bold;">Unique capabilities:</span> &nbsp;Solving hypersensitive&nbsp;problems from empirical&nbsp;data<br>&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#Direct_polynomial_manipulation">&nbsp;Intuitive WYSIWYG polynomial
computation interface</a> in Matlab <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp;<a href="#Solving_linear_equations">Solving linear operator equation</a> &nbsp;<span style="font-style: italic;">L</span>(<span style="font-style: italic;">z</span>)<span style="font-style: italic;"> = b</span> directly from linear transformation <span style="font-style: italic;">L</span> even if it is rank-deficient<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <small><span style="color: rgb(255, 204, 0); font-style: italic;">New!</span></small>&nbsp;&nbsp;<a href="#Rank-r_Newton">Rank-r Newton's iteration</a> solving nonlinear systems &nbsp;f(x) = 0 with non-isolated solutions and singular Jacobians<br>&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;solving<a href="#GaussNewton"> nonlinear least squares</a> problem with Gauss-Newtion iterations.<span style="font-weight: bold;"><br><br></span><big><big style="font-weight: bold;">Featured modules:</big></big> &nbsp; &nbsp; <a href="#Solving_polynomial_systems">Polynomial systems</a>, <a href="#ApproxiJordanForm">Jordan Canonical Forms</a>, <a href="#Multiplicity">multiplicities of nonlinear systems</a>,&nbsp;<br>&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<a href="#pgcd">polynomial GCD</a> /<a href="#pfac"> </a><a href="#pfac">factorizations</a>, ....<br><big style="font-weight: bold;"><big>Research toolbox:</big></big> &nbsp; &nbsp; &nbsp; Generic<a href="#Solving_linear_equations"> linear equation solver </a>without matrices, <a href="#GaussNewton">Gauss-Newton iteration</a>, <a href="#Rank-r_Newton">rank-r Newton's iteration</a> ....<span style="font-style: italic;"><span style="font-style: italic;"></span></span><br style="font-weight: bold;"><big style="font-weight: bold;"><big><span style="font-weight: bold;">Software building blocks &nbsp;<a href="#software_building_blocks"><small><small><small>[Link]</small></small></small></a></span></big></big> <p><b><font face="Agency FB" size="4"><a name="About"></a>NAClab&nbsp;</font></b><small>a joint research project in development by Tien-Yien Li and Zhonggang
Zeng&nbsp;<span style="font-size: 22pt;"><font size="3"><small> It is</small></font></span> an expansion from its predecessor<b><font face="Agency FB" size="4"><small> Apalab</small></font></b>
(and its Maple counterpart is&nbsp; <b> <font face="Agency FB" size="4"><small> <a href="https://web.archive.org/web/20210728230327/http://homepages.neiu.edu/%7Ezzeng/apatools.htm">
ApaTools</a></small></font></b>).&nbsp;&nbsp;. &nbsp;<font color="#ff0000"><b><u>Disclaimer:</u>&nbsp;&nbsp;
NAClab is an on-going
research project,&nbsp; Bugs
and
shortcomings likely exist.&nbsp; The authors are not
responsible for any
damage&nbsp; or loss from using this software. Users should verify
their
results through whatever means.</b></font></small><br>
</p><p>Project leaders: &nbsp;<span style="font-weight: bold;"> Tien-Yien Li</span><span style="font-weight: bold;"> &nbsp;</span>and<span style="font-weight: bold;">&nbsp; </span><span style="font-weight: bold;">Zhonggang Zeng &nbsp;(</span><a name="Contact"></a>Contact via email: &nbsp;zzeng at &nbsp;neiu dot edu )<br>Colaborators/contributors: &nbsp;Liping Chen, Tianran Chen, Wenrui Hao, Tsung-Lin Lee, Wenyuan Wu, Andrew Sommese</p><h1><img style="width: 51px; height: 43px;" alt="!!!New!!!" src="NewSymbol.jpg"><a name="Solving_linear_equations"></a>Solving&nbsp;linear equations &nbsp;<span style="font-style: italic;">L</span>(<span style="font-style: italic;">z</span>) =&nbsp;<span style="font-style: italic;">b </span>&nbsp;<br><small><small>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; - directly from linear transformation <span style="font-style: italic;">L</span> without representation matrix</small></small><br><small><small>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;- including homogeneous equation &nbsp;<span style="font-style: italic;">L(z) = 0 &nbsp;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -&nbsp;</span>even if&nbsp; <span style="font-style: italic;">L</span> is rank-deficient &nbsp;</small></small></h1><p>NAClab can directly solve a general linear equation &nbsp; L(z) = b &nbsp;for its <span style="font-style: italic; text-decoration: underline;">general</span>
numerical solution&nbsp; where L is a linear transformation between
(products of) vector spaces. As a special case, the module <a href="#LinearSolve">LinearSolve</a>
solves L(z) = 0 for the numerical kernel. &nbsp; &nbsp;<span style="font-size: 10pt;">[<a href="https://doi.org/10.1007/978-3-319-96418-8_59"> </a><a href="https://doi.org/10.1007/978-3-319-96418-8_59">A short paper on&nbsp; LinearSolve</a> ]</span></p><p>A general numerical solution within an error tolerance is in the form of&nbsp;<span style="font-family: Symbol;"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><big>z</big> = <big>z</big><small><small>0</small></small> + <big>c</big><small><small><small>1</small></small></small>*<big>z</big><small><small><small>1</small></small></small>+...+<big>c</big><small><small>k</small></small>*<big>z</big><small><small>k</small></small> &nbsp;<br>where&nbsp;<big>z</big><small><small>0</small></small> is the minimum norm solution, <big>c</big><small><small>1</small></small>,..,<big>c</big><small><small>k</small></small> are constants and {<big>z</big><small><small>1</small></small>,...,<big>z</big><small><small>k</small></small>} forms a basis for the numerical kernel of L within the error tolerance </p><p>For<a href="https://web.archive.org/web/20210728230327/http://homepages.neiu.edu/~zzeng/NAClab/LinearSolveDemo1.pdf"> a demo</a>, NAClab outputs polynomials <span style="font-style: italic;">f</span> and <span style="font-style: italic;">g &nbsp;</span>such that &nbsp; &nbsp;<span style="font-style: italic;">p f + q g &nbsp;= u &nbsp; </span>where &nbsp;<span style="font-style: italic;">p, q&nbsp; </span>are given polynomials of degrees <span style="font-style: italic;">m </span>and <span style="font-style: italic;">n</span> &nbsp;respectivly and &nbsp;<span style="font-style: italic;">u = GCD(p,q)</span> of degree <span style="font-style: italic;">k</span>. In other words, NAClab solves the linear equation<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="font-style: italic;">L(f,g) &nbsp;= u<br>where &nbsp; L </span>is the linear transformation defined by &nbsp;<span style="font-style: italic;">L(f,g) &nbsp;= p f + q g</span> &nbsp;with fixed parameters <span style="font-style: italic;">p, q</span>.
&nbsp;Users do not need to provide representation matrices for the
linear transformations unless they choose to do so. &nbsp;NAClab
generates representation matrices internally.&nbsp;</p><p>The complete process for this example is as follows</p><p>Define an annonymous function for the linear transformation&nbsp;</p><p><span style="font-family: Courier New; color: rgb(0, 0, 238);">&gt;&gt; map2gcd = @(f,g,</span><span style="font-family: Courier New; color: rgb(0, 0, 238);">p,q</span><span style="font-family: Courier New; color: rgb(0, 0, 238);">)</span><span style="font-family: Courier New; color: rgb(0, 0, 238);"> pplus(ptimes(p,f),ptimes(q,g));</span></p>Enter polynomials f, g, u as character strings, provide the domain and parameter for the linear transformation:<br><br><span style="color: rgb(0, 0, 238); font-family: Courier New,Courier,monospace;">&gt;&gt; f = '5.99999 - 9*x + 3*x^3 - 4*x^4 + 6*x^5 - 2*x^7';</span><br style="color: rgb(0, 0, 238); font-family: Courier New,Courier,monospace;"><span style="color: rgb(0, 0, 238); font-family: Courier New,Courier,monospace;">&gt;&gt; g = '-2 + 5*x - 3*x^2 - x^3 + x^4 + 2*x^5 - 3.00002*x^6 + x^8';</span><br style="color: rgb(0, 0, 238); font-family: Courier New,Courier,monospace;"><span style="color: rgb(0, 0, 238); font-family: Courier New,Courier,monospace;">&gt;&gt; u = '2-2.99999*x+1.00001*x^3';</span><br style="color: rgb(0, 0, 238); font-family: Courier New,Courier,monospace;"><span style="color: rgb(0, 0, 238); font-family: Courier New,Courier,monospace;">&gt;&gt; domain = {'1+x+x^2+x^3+x^4+x^5','1+x+x^2+x^3+x^4'};<br>&gt;&gt; parameter = {f,g};<br></span><br>Just like that, we are ready to call LinearSolve with error tolerance 1e-4<br><br><span style="color: rgb(0, 0, 238); font-family: Courier New,Courier,monospace;">&gt;&gt; [Z,K,lcond,res] = LinearSolve({map2gcd,domain,parameter}, u, 1e-4);</span><br style="font-family: Courier New,Courier,monospace;"><br>The minimum norm solution:<br><br><span style="color: rgb(0, 0, 238); font-family: Courier New,Courier,monospace;">&gt;&gt; Z</span><br style="color: rgb(0, 0, 238); font-family: Courier New,Courier,monospace;"><br style="color: rgb(0, 0, 238); font-family: Courier New,Courier,monospace;"><span style="color: rgb(0, 0, 238); font-family: Courier New,Courier,monospace;">Z = </span><br style="color: rgb(0, 0, 238); font-family: Courier New,Courier,monospace;"><br style="color: rgb(0, 0, 238); font-family: Courier New,Courier,monospace;"><span style="color: rgb(0, 0, 238); font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp;
'0.315213638005548 + 0.0325895733429298*x +
0.021703â¦'&nbsp;&nbsp;&nbsp;&nbsp; '-0.054358027177057 +
0.0434095337991119*x + 0.10852â¦' </span><br><br>The numerical kernel within the error tolerance 1e-4:<br><br><span style="font-family: Courier New; color: rgb(0, 0, 238);">&gt;&gt; K{:}</span><br style="font-family: Courier New; color: rgb(0, 0, 238);"><br style="font-family: Courier New; color: rgb(0, 0, 238);"><span style="font-family: Courier New; color: rgb(0, 0, 238);">ans = </span><br style="font-family: Courier New; color: rgb(0, 0, 238);"><br style="font-family: Courier New; color: rgb(0, 0, 238);"><span style="font-family: Courier New; color: rgb(0, 0, 238);">&nbsp;&nbsp;&nbsp;
'0.249999389461494 - 0.250001189336557*x -
0.2500021â¦'&nbsp;&nbsp;&nbsp;&nbsp; '0.74999762066815 -
0.500002203566776*x^4'</span><br><br><h1><img style="width: 51px; height: 43px;" alt="!!!New!!!" src="NewSymbol.jpg"><a name="Rank-r_Newton"></a>Rank-r Newton's iteration <small><small><small>(<a href="Papers/Rank-r_Newton.pdf">preprint</a> with examples, <a href="#Newton">syntax</a>) </small></small></small><br><small><small>&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; - solve
nonlinear system&nbsp; f(x) = 0 even if the solution is non-isolated</small></small><br><small><small>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;- directly from smooth mapping f between products of vector spaces <span style="font-style: italic;">&nbsp;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -&nbsp;</span>even if&nbsp; the Jacobian is rank-deficient &nbsp;</small></small></h1><h1>&nbsp;<a name="Solving_polynomial_systems"></a>Solving polynomial systems <br><small><small><small><small>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</small><small>by the homotopy method based on <a href="https://web.archive.org/web/20250000000000*/http://hom4ps.math.msu.edu/">HOM4PS</a></small></small></small></small></h1>
Polynomials systems can be solved &nbsp;for numerical solutions in a
straightforward and intuitive setting. &nbsp;For example: To solve the
following polynomial system with 20 zeros<br><br>&nbsp; &nbsp; &nbsp;-x^5 + y^5 - 3*y - 1 = 0<br>&nbsp; &nbsp; &nbsp;5*y^4-3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; = 0<br>&nbsp; &nbsp;&nbsp; &nbsp;-20*x+y-z &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; = 0<br><br><span style="font-family: Courier New;">simply call "psolve" with straitforward input [ <a href="#psolve">more details</a> ]<br><br><span style="color: rgb(51, 51, 255); font-weight: bold;">&gt;&gt; P = {'-x^5+y^5-3*y-1','5*y^4-3','-20*x+y-z'};<small><small>&nbsp;<big><big><big> <small>% </small></big></big></big></small></small></span><small><span style="color: rgb(51, 51, 255);"><small><small><big><big><big>define the polynomial system</big></big></big></small></small></span></small></span><br>
<span style="font-family: Courier New;"><span style="color: rgb(51, 51, 255); font-weight: bold;">&gt;&gt; [Solutions, variables] = psolve(P) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; % </span><span style="color: rgb(51, 51, 255);">call the polynomial system solver</span><span style="color: rgb(51, 51, 255); font-weight: bold;"><br><small><small><small><br></small></small></small>&nbsp; &nbsp;<small><small>Solutions =<br><br>&nbsp; &nbsp;&nbsp; Column 1<br><br>&nbsp; &nbsp;&nbsp; 0.778497746685646 + 0.893453081179308i<br>&nbsp; &nbsp; -0.000000000000000 + 0.880111736793394i<br>&nbsp; &nbsp;-15.569954933712914 -16.988949886792764i<br><br>&nbsp; &nbsp;&nbsp; ... ...<br><br>&nbsp; &nbsp;&nbsp; Column 20<br><br>&nbsp; &nbsp;&nbsp; 0.778497746685646 - 0.893453081179308i<br>&nbsp; &nbsp;&nbsp; 0.000000000000000 - 0.880111736793393i<br>&nbsp; &nbsp;-15.569954933712925 +16.988949886792767i<br><br><br>&nbsp; &nbsp;variables = <br><br>&nbsp;&nbsp;&nbsp; 'x'&nbsp;&nbsp;&nbsp; 'y'&nbsp;&nbsp;&nbsp; 'z'</small></small><br><br></span></span>
<h1>&nbsp;<a name="Direct_polynomial_manipulation"></a>Direct polynomial
manipulation: &nbsp;</h1>

<p>Polynomials can now be entered and shown as character strings, such as
&nbsp;<br>
<span style="font-family: Courier New;">&nbsp;
&nbsp;<span style="color: rgb(51, 51, 255); font-weight: bold;">&gt;&gt;
f = '3*x^2 - (2-5i)*x^3*y^4 - 1e-3*z^5-6.8'</span><br style="color: rgb(51, 51, 255);">
<span style="color: rgb(51, 51, 255);">&nbsp;
&nbsp;<span style="font-weight: bold;">&gt;&gt;
g = '-2*y^3 - 5*x^2*z + 8.2'</span></span><span style="color: rgb(51, 51, 255);"><span style="font-weight: bold;"></span></span></span></p>
<p>Using
polynomials strings as input, users can now perform&nbsp;common
polynomial operations &nbsp;such as addition, multiplication,
power,
evaluation, differentiation,&nbsp;factorization, extracting
coefficients, finding greatest common divison (GCD), by calling NAClab
functions, such as<span style="font-family: Courier New;"><br>
&nbsp; &nbsp;<span style="color: rgb(51, 51, 255); font-weight: bold;">&gt;&gt;
p = PolynomialPlus('2*x^5-3*y','4+x*y')</span> &nbsp;
&nbsp; <span style="color: black;">% add any number
of polynomials</span><br>
&nbsp; &nbsp;<span style="color: rgb(51, 51, 255); font-weight: bold;">&gt;&gt;
q = PolynomialTimes(f,g,h)</span> &nbsp;% multiply any number
of polynomials<br>
&nbsp; &nbsp;<span style="font-weight: bold; color: rgb(51, 51, 255);">&gt;&gt;
v = PolynomialEvaluate(f,{'x','z'},[3,4])</span> % evaluate
f(x,y,z) for x=3, z=4<br>
</span>and <a href="https://web.archive.org/web/20210728230327/http://homepages.neiu.edu/%7Enaclab/#quick_access">a lot more</a>.
&nbsp;For example, to compute a greatest common divisor:</p>
<p><span style="font-family: Courier New;"><span style="font-family: Courier New;">&nbsp; &nbsp;<span style="color: rgb(51, 51, 255); font-weight: bold;">&gt;&gt;
f = '10 - 5*x^2*y + 6*x*y^2 - 3*x^3*y^3';</span><br style="color: rgb(51, 51, 255); font-weight: bold;">
<span style="color: rgb(51, 51, 255); font-weight: bold;">&nbsp;
&nbsp;&gt;&gt; g = '30 + 10*y + 18*x*y^2 + 6*x*y^3'</span><br style="color: rgb(51, 51, 255); font-weight: bold;">
<span style="color: rgb(51, 51, 255); font-weight: bold;">&nbsp;
&nbsp;&gt;&gt; u = PolynomialGCD(f,g)</span><br style="color: rgb(51, 51, 255); font-weight: bold;">
<span style="color: rgb(51, 51, 255); font-weight: bold;">&nbsp;
&nbsp;u =</span><br style="color: rgb(51, 51, 255); font-weight: bold;">
<span style="color: rgb(51, 51, 255); font-weight: bold;">&nbsp;
&nbsp;33.5410196624968 + 20.1246117974981*x*y^2</span></span></span></p>
<h1>&nbsp;<img style="width: 120px; height: 90px;" alt="Key" src="../naclab/hammer1.jpg"><a name="Key_features:"></a>Key features:</h1>
The functions for<br>
<ul>
<li>Solving polynomial systems</li><li>Polynomial GCD</li>
<li>Polynomial Factorization</li>
<li>Multiplicity and dual spaces of a nonlinear system at a zero</li>
<li>Numerical Jordan Canonical Form</li>
<li>Numerical Rank revealing and updating/downdating</li>
</ul>
are
major development in both algorithm design and software
implementations. For instance, the univariate factorization is based on
<a href="myaward.jpg">an
award winning paper on accurate computation of multiple roots</a>
<p><span style="font-family: Courier New;"><span style="font-family: Courier New;"></span></span></p>
<h1><font size="5"><a name="Table_of_contents"></a>Table
of contents</font></h1>
<ul>
<li><a href="#download">Download and
installation</a></li>
<li><a href="#List_of_functions:">List of functions</a><br>
<ul>
<li><a href="#quick_access">Quick-access
polynomial functions</a></li>
<li><a href="#Expert_functions">Programming
tools for polynomial computation</a></li>
<li><a href="#Matrix_computation_functions">Matrix
computations<br>
</a>
<ul>
<li><a href="#Major_LA_packages">Major
packages</a></li>
<li><a href="#LA_Programming_utilities">Programming
utilities</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
</ul>
<p>
<br>
</p>
<h1><a name="List_of_functions:"></a><u><font size="5"><b>List of functions</b>:</font></u></h1>
<p><font face="Arial Narrow">&nbsp;&nbsp;&nbsp;&nbsp;
</font>Functions are in three categories: &nbsp;<a href="#quick_access">Queck-access</a> functions,
&nbsp;<a href="#Expert_functions">Programming
tools for polynomial compuations</a>,&nbsp; and &nbsp;<a href="#Matrix_computation_functions">Matrix compuation tools</a></p>
<h1><font><font size="5"><b><a name="quick_access">Quick-access polynomial functions</a></b>:</font></font></h1>
Functions in this category accept input polynomials as character
strings, such as<br>
<span style="font-family: Courier New;">&nbsp;
&nbsp;<span style="color: rgb(51, 51, 255); font-weight: bold;">&gt;&gt;
f = '3*x^2 - (2-5i)*x^3*y^4 - 1e-3*z^5-6.8'</span><br style="color: rgb(51, 51, 255);">
<span style="color: rgb(51, 51, 255);">&nbsp;
&nbsp;<span style="font-weight: bold;">&gt;&gt;
g = '-2*y^3 - 5*x^2*z + 8.2'</span></span></span><span style="font-family: Arial Narrow;"><span style="font-weight: bold;"></span></span><br>
A list of quick access functions are as follows. &nbsp;Use, say <span style="font-weight: bold; color: rgb(51, 51, 255); font-family: Courier New;">&gt;&gt;
help GetVariables</span>, to access documentations.
&nbsp;Many functions have shortened aliases. For example, <span style="color: rgb(51, 51, 255); font-family: Courier New; font-weight: bold;">pvar</span>
is an alias for <span style="font-weight: bold; color: rgb(51, 51, 255); font-family: Courier New;">GetVariables</span>.
&nbsp;<br>
<ul>
<li><a href="/#GetVariables"><span style="font-weight: bold; color: rgb(51, 51, 255); font-family: monospace;">GetVariables</span>
</a>&nbsp;(alias <span style="font-weight: bold; color: rgb(51, 51, 255); font-family: monospace;">pvar</span>)
&nbsp; --- extracting variable names of a polynomial</li>
<li><a href="#pcoef"><span style="font-family: monospace; font-weight: bold; color: rgb(51, 51, 255);">PolynomialCoefficient</span></a>
(alias <span style="color: rgb(51, 51, 255); font-weight: bold; font-family: monospace;">pcoef</span>)
&nbsp;--- extracting a coefficient</li>
<li><a href="%7Enaclab/#pder"><span style="font-weight: bold; font-family: monospace; color: rgb(51, 51, 255);">PolynomialDerivative</span></a>
(alias <span style="font-weight: bold; color: rgb(51, 51, 255); font-family: monospace;">pder</span>)
--- partial derivative of a polynomial</li>
<li><a href="#peval"><span style="font-weight: bold; font-family: monospace; color: rgb(51, 51, 255);">PolynomialEvaluate</span></a>
(alias <span style="font-weight: bold; color: rgb(51, 51, 255); font-family: monospace;">peval</span>)
--- polynomial evaluation</li>
<li><a href="#pfac"><span style="font-weight: bold; font-family: monospace; color: rgb(51, 51, 255);">PolynomialFactor</span></a>
(alias <span style="font-weight: bold; color: rgb(51, 51, 255); font-family: monospace;">pfac</span>)
--- numerical polynomial factorization (multivariate irreducible
factorization is an on-going joint work with Wenyuan Wu)</li>
<li><a href="#pgcd"><span style="font-weight: bold; font-family: monospace; color: rgb(51, 51, 255);">PolynomialGCD</span></a>
(alias <span style="font-weight: bold; color: rgb(51, 51, 255); font-family: monospace;">pgcd</span>)
--- computing the numerical greatest common divisor of a
polynomial&nbsp;</li>
<li><a href="#pplus"><span style="font-weight: bold; font-family: monospace; color: rgb(51, 51, 255);">PolynomialPlus</span></a>
(alias <span style="font-weight: bold; color: rgb(51, 51, 255); font-family: monospace;">pplus</span>)
--- &nbsp;addition of any number of polynomials</li>
<li><a href="#pminus"><span style="font-weight: bold; font-family: monospace; color: rgb(51, 51, 255);">PolynomialMinus</span></a>
(alias <span style="font-weight: bold; color: rgb(51, 51, 255); font-family: monospace;">pminus</span>)
--- &nbsp;a polynomial minus another</li>
<li><a href="#ptimes"><span style="font-weight: bold; font-family: monospace; color: rgb(51, 51, 255);">PolynomialTimes</span></a>
(alias <span style="font-weight: bold; color: rgb(51, 51, 255); font-family: monospace;">ptimes</span>)
--- &nbsp;multiplication of any number of polynomials</li>
<li><a href="#ppower"><span style="font-weight: bold; font-family: monospace; color: rgb(51, 51, 255);">PolynomialPower</span></a>
(alias <span style="font-weight: bold; color: rgb(51, 51, 255); font-family: monospace;">ppower</span>)
---&nbsp; a polynomial raised to a power</li>
<li><a href="#pnorm"><span style="font-weight: bold; font-family: monospace; color: rgb(51, 51, 255);">PolynomialNorm</span>
</a>(alias <span style="font-weight: bold; color: rgb(51, 51, 255); font-family: monospace;">pnorm</span>)
---&nbsp; calculating the 2-norm of a polynomial</li>
<li><a href="#psup"><span style="font-weight: bold; font-family: monospace; color: rgb(51, 51, 255);">PolynomialSupport</span>
</a>(alias <span style="font-weight: bold; color: rgb(51, 51, 255); font-family: monospace;">psup</span>)
---&nbsp; extracting the monomial support of polynomials</li>
<li><a href="#pclear"><span style="font-weight: bold; font-family: monospace; color: rgb(51, 51, 255);">PolynomialClear</span></a>
(alias <span style="font-weight: bold; color: rgb(51, 51, 255); font-family: monospace;">pclear</span>)
---&nbsp; Clearing tiny coefficients, real parts and imaginary
parts of a polynomial</li>
<li><a href="#PolynomialJacobian"><span style="font-weight: bold; font-family: monospace; color: rgb(51, 51, 255);">PolynomialJacobian</span></a>
(alias <span style="font-weight: bold; color: rgb(51, 51, 255); font-family: monospace;">pjac</span>)
---&nbsp; Generating the (symbolic) Jacobian matrix of a polynomial
system</li><li><a href="#psolve">psolve</a> --- Solve polynomial systems by homotopy method</li>
<li><a href="#TotalDegree"><span style="font-weight: bold; font-family: monospace; color: rgb(51, 51, 255);">TotalDegree</span></a>&nbsp;
--- &nbsp;extracting the total degree of a polynomial</li>
<li><a href="#TupleDegree"><span style="font-weight: bold; font-family: monospace; color: rgb(51, 51, 255);">TupleDegree</span></a>&nbsp;
--- &nbsp;extracting the tuple degree of a polynomial</li><li><a href="#FactorDistance">FactorDistance</a> --- &nbsp;calculate the distance between two polynomial factorizations</li>
<li><a href="#prand"><span style="font-weight: bold; font-family: monospace; color: rgb(51, 51, 255);">RandomPolynomial</span></a>
(alias <span style="font-weight: bold; color: rgb(51, 51, 255); font-family: monospace;">prand</span>)
---&nbsp; generating a random polynomial</li>
<li><a href="#Multiplicity"><span style="font-weight: bold; font-family: monospace; color: rgb(51, 51, 255);">Multiplicity</span></a>&nbsp;<span style="font-weight: bold; color: rgb(51, 51, 255); font-family: monospace;"></span>
---&nbsp; computing the multiplicity structure, a.k.a. dual space,
of a
polynomial system at an isolated zero (joint work with Wenrui Hao and
Andrew Sommese)</li><li><a href="#ShowDual"><span style="font-weight: bold; font-family: monospace; color: rgb(51, 51, 255);">ShowDual</span></a>--- Display the dual basis computed by <a href="https://web.archive.org/web/20210728230327/http://homepages.neiu.edu/%7Enaclab/#Multiplicity">Multiplicity</a></li>
<li><a href="#ConvolutionMatrix"><span style="font-weight: bold; font-family: monospace; color: rgb(51, 51, 255);">ConvolutionMatrix</span></a>&nbsp;
--- &nbsp;generating the convolution matrix of a univariate
polynomial</li>
<li><a href="#SylvesterMatrix"><span style="font-weight: bold; font-family: monospace; color: rgb(51, 51, 255);">SylvesterMatrix</span></a>&nbsp;
--- &nbsp;generating the Sylvester matrix of a univariate polynomial</li><li><a href="#BezoutMatrix"><span style="font-weight: bold; font-family: monospace; color: rgb(51, 51, 255);">BezoutMatrix</span></a>&nbsp;
--- &nbsp;generating the Bezout matrix of two univariate polynomials</li><li><a href="#CompanionMatrix"><span style="font-weight: bold; font-family: monospace; color: rgb(51, 51, 255);">CompanionMatrix</span></a>&nbsp;
--- &nbsp;generating the companion matrix of a univariate polynomial<br><a href="#MacaulayMatrix"><span style="font-weight: bold; font-family: monospace; color: rgb(51, 51, 255);">MacaulayMatrix</span></a>&nbsp;
--- &nbsp;generating the Macaulay matrix for multiplicity structure of a multiple zero of a polynomial system</li>
</ul>
<h1><font><font><font><font size="5"><b><a name="Expert_functions"></a>Programming tools for
polynomial computations</b>:</font></font></font></font></h1>
<p>Functions
in this category are designed for experts for developing algorithms and
implementations for numerical polynomial algebra. These functions
requires polynomials represented as either a coefficient matrix or a
coefficient vector. &nbsp;</p>
<p>A univariate polynomial is represented by its <b>coefficient
vector</b>.&nbsp; For example,&nbsp;
<i>f</i>(<i>x</i>) = <i>x<sup>3</sup>
+ 2x<sup><font face="p">2</font></sup> +
3x + 4&nbsp; </i>is represented as<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font face="Courier New"> &gt;&gt; f&nbsp; =&nbsp;
[1, 2, 3, 4]</font>&nbsp;&nbsp; % or&nbsp; its
transpose</p>
<p>An<i>&nbsp; m-</i>multivariate
polynomial&nbsp; <i>f&nbsp; </i>of <i>&nbsp;n&nbsp;
</i>terms <i>is</i> represented by a <b>coefficient
matrix</b>&nbsp; <i>F&nbsp;
</i>of size&nbsp; (<i>m+</i>1)<span style="font-family: Courier New;"> by&nbsp;</span><i>
n </i>&nbsp;according to the following rules:<br>
&nbsp;&nbsp;&nbsp;&nbsp; 1.&nbsp; Every column
of&nbsp; <i>F </i>&nbsp;represents one term
(monomial)<br>
&nbsp;&nbsp;&nbsp;&nbsp; 2.&nbsp; <i>F</i>(<i>i,j</i>)&nbsp;&nbsp;&nbsp;
for<i> i&lt;m+</i>1&nbsp;&nbsp; is the exponent
of the <i>i</i>-th variable on <i>j</i>-th
term<br>
&nbsp;&nbsp;&nbsp;&nbsp; 3.&nbsp; <i>F</i>(<i>m+</i>1,<i>j</i>)&nbsp;
is the coefficient of the <i>j</i>-th term<br>
For example, let &nbsp; &nbsp;<i><font size="4">p</font></i><font size="4">(<i>x, y, z</i>)&nbsp; =&nbsp; </font><i><font size="4">8.5&nbsp; +&nbsp; </font></i><font size="4">(</font><i><font size="4">3-2i</font></i><font size="4">)</font><i><font size="4">x<sup>3</sup>
y&nbsp; +&nbsp; 5 x<sup>2</sup> z<sup>5</sup>&nbsp;&nbsp;
-&nbsp; 2 y<sup>3</sup>&nbsp;&nbsp; + 6 y<sup>3</sup>
z<sup>2</sup> &nbsp;</font></i>.
&nbsp; Users can transform its string representation to coefficient
matrix representation by calling the quick access function <span style="font-weight: bold; color: rgb(51, 51, 255); font-family: Courier New;">PolynString2CoefMat</span>
: &nbsp;<br>
<span style="color: rgb(51, 51, 255); font-weight: bold; font-family: Courier New;">&nbsp;
&nbsp;&gt;&gt; f = '8.5 + (3-2i)*x^3*y + 5*x^2*z^5 - 2*y^3
+ 6*y^3*z^2';</span><br style="color: rgb(51, 51, 255); font-weight: bold; font-family: Courier New;">
<span style="color: rgb(51, 51, 255); font-weight: bold; font-family: Courier New;">&nbsp;
&nbsp;&gt;&gt; F = PolynString2CoefMat(f,{'x','y','z'})<br>
&nbsp; &nbsp;F =<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;
3.0000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; &nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.0000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;
1.0000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; &nbsp;3.0000&nbsp;&nbsp;&nbsp;&nbsp;
3.0000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; &nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;
2.0000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.0000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<br>
&nbsp;&nbsp; 8.5000&nbsp;&nbsp;&nbsp;&nbsp;
3.0000 - 2.0000i&nbsp;
&nbsp; &nbsp;-2.0000&nbsp;&nbsp;&nbsp;&nbsp;
6.0000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.0000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span><span style="color: rgb(51, 51, 255); font-weight: bold; font-family: Courier New;"></span></p>
<p>The following are a list of expert functions as <a name="software_building_blocks"></a>software building blocks</p>
<ul>
<li>Main specialty functions<br>
<ul>
<li><a href="#LinearTransformMatrix"><span style="font-weight: bold; font-family: monospace; color: rgb(51, 51, 255);">LinearTransformMatrix</span></a>
---&nbsp; generate the matrix from a given linear transformation</li><li><a href="#LinearSolve">LinearSolve</a> &nbsp;--- solve a linear operator equation and matrix-vector equations</li>
<li><a href="#GaussNewton"><span style="font-weight: bold; font-family: monospace; color: rgb(51, 51, 255);">GaussNewton</span></a>
---&nbsp; solve a nonlinear least squares problem by the
Gauss-Newton iteration&nbsp;</li><li><a href="#Newton">Newton</a> --- Conventional and rank-r Newton's iteration for solving operator equations f(x)=0</li>
</ul>
</li>
</ul>
<ul>
<li>Transition functions between quick-access and expert
functions<br>
<ul>
<li><a href="#PolynString2CoefMat"><span style="font-weight: bold; font-family: monospace; color: rgb(51, 51, 255);">PolynString2CoefMat</span></a>
---&nbsp; transform a polynomial string to its coefficient matrix</li>
<li><a href="#CoefMat2PolynString"><span style="font-weight: bold; font-family: monospace; color: rgb(51, 51, 255);">CoefMat2PolynString</span></a>
---&nbsp; transform a polynomial coefficient matrix to its
character string representation</li>
</ul>
</li>
</ul>
<ul>
<li>Functions for univariate polynomial compuation<br>
<ul>
<li><a href="#uvGCD"><span style="font-weight: bold; font-family: monospace; color: rgb(51, 51, 255);">uvGCD</span></a>
---&nbsp; computing the GCD of a univariate polynomial pair</li>
<li><a href="#uvGCDfixedDegree"><span style="font-weight: bold; font-family: monospace; color: rgb(51, 51, 255);">uvGCDfixedDegree</span></a>
---&nbsp; compute the numerical GCD of two univariate polynomials
with a given GCD degree</li>
<li><a href="#ExtendedGCD"><span style="font-weight: bold; font-family: monospace; color: rgb(51, 51, 255);">ExtendedGCD</span></a>
---&nbsp; computing polynomials&nbsp;<span style="font-style: italic;">p</span> and&nbsp;<span style="font-style: italic;">q</span> &nbsp;such
that&nbsp;<span style="font-style: italic;">pf+qg =
gcd(f,g)</span></li>
<li><a href="#uvFactor"><span style="font-weight: bold; font-family: monospace; color: rgb(51, 51, 255);">uvFactor</span></a>
---&nbsp; univariate factorization</li>
<li><a href="#ConvolutionMatrix"><span style="font-weight: bold; font-family: monospace; color: rgb(51, 51, 255);">ConvolutionMatrix</span></a>
---&nbsp; computing the convolution matrix of a polynomial</li>
<li><a href="#SylvesterMatrix"><span style="font-weight: bold; font-family: monospace; color: rgb(51, 51, 255);">SylvesterMatrix</span></a>
---&nbsp; computing the Sylvester matrix</li>
</ul>
</li>
</ul>
<ul>
<li>Functions for multivariate polynomial computation<br>
<ul>
<li><a href="#mvPolynAdd"><span style="font-weight: bold; font-family: monospace; color: rgb(51, 51, 255);">mvPolynAdd</span></a>
---&nbsp; add two polynomials represented as coefficient matrices</li>
<li><a href="#mvPolynClear"><span style="font-weight: bold; font-family: monospace; color: rgb(51, 51, 255);">mvPolynClear</span></a>
---&nbsp; clear tiny coefficients, real parts and imaginary parts
of a polynomial represented as a coefficient matrix</li>
<li><a href="#mvPolynCoefMat2Vec"><span style="font-weight: bold; font-family: monospace; color: rgb(51, 51, 255);">mvPolynCoefMat2Vec</span></a>
---&nbsp; convert a coefficient matrix to a coefficient vector (in
sparse form) of a polynomial</li>
<li><a href="#mvPolynCoefVec2Mat"><span style="font-weight: bold; font-family: monospace; color: rgb(51, 51, 255);">mvPolynCoefVec2Mat</span></a>
---&nbsp; convert a coefficient vector to a coefficient matrix of
polynomial</li>
<li><a href="#mvPolynDegree"><span style="font-weight: bold; font-family: monospace; color: rgb(51, 51, 255);">mvPolynDegree</span></a>
---&nbsp; extract the (tuple or total) degree of a polynomial
represented as a coefficient matrix</li>
<li><a href="#mvPolynDerivative"><span style="font-weight: bold; font-family: monospace; color: rgb(51, 51, 255);">mvPolynDerivative</span></a>
---&nbsp; take a partial derivative of a polynomial represented as
a coefficient matrix</li>
<li><a href="#mvPolynEvaluate"><span style="font-weight: bold; font-family: monospace; color: rgb(51, 51, 255);">mvPolynEvaluate</span></a>
---&nbsp; evaluate a polynomial represented as a coefficient matrix</li><li><a href="#mvPolynIndexer"><span style="font-weight: bold; font-family: monospace; color: rgb(51, 51, 255);">mvPolynIndexer</span></a>
---&nbsp; generate the indexing vector from a tuple degree bound</li>
<li><a href="#mvPolynMonomTotal"><span style="font-weight: bold; font-family: monospace; color: rgb(51, 51, 255);">mvPolynMonomTotal</span></a>
---&nbsp; calcuate the number of monomials from a given degree bound</li>
<li><a href="#mvPolynMonomBasis"><span style="font-weight: bold; font-family: monospace; color: rgb(51, 51, 255);">mvPolynMonomBasis</span></a>
---&nbsp; Generate monomial basis from a given degree bound</li>
<li><a href="#mvPolynMultiply"><span style="font-weight: bold; font-family: monospace; color: rgb(51, 51, 255);">mvPolynMultiply</span></a>
---&nbsp; multiply two polynomials represented as coefficient
matrices</li>
<li><a href="#mvPolynPower"><span style="font-weight: bold; font-family: monospace; color: rgb(51, 51, 255);">mvPolynPower</span></a>
---&nbsp; raise a power of a polynomial represented as a
coefficient matrix</li>
<li><a href="#mvPolynProject"><span style="font-weight: bold; font-family: monospace; color: rgb(51, 51, 255);">mvPolynProject</span></a>
---&nbsp; project an m-variate polynomial to an n-variate
polynomial (m&gt;n) by setting m-n variables as constant.</li>
<li><a href="#mvPolynSort"><span style="font-weight: bold; font-family: monospace; color: rgb(51, 51, 255);">mvPolynSort</span></a>
---&nbsp; sort polynomial terms in lexicographical order</li>
<li><a href="#mvPolynTimesMonom"><span style="font-weight: bold; font-family: monospace; color: rgb(51, 51, 255);">mvPolynTimesMonom</span></a>
---&nbsp; multiply a polynomial by a monomial</li><li><a href="#GrlexMonomialIndex"><span style="font-weight: bold; font-family: monospace; color: rgb(51, 51, 255);">GrlexMonomialIndex</span></a> ---&nbsp; Find the index of a monomial in the graded lexicographical order</li><li><a href="#GrlexNextMonomial"><span style="font-weight: bold; font-family: monospace; color: rgb(51, 51, 255);">GrlexNextMonomial</span></a> ---&nbsp; Find the next monomial in the graded lexicographical order</li>
<li><a href="#SquarefreeFactor"><span style="font-weight: bold; font-family: monospace; color: rgb(51, 51, 255);">SquarefreeFactor</span></a>
---&nbsp; calculate a squarefree factorization of a
polynomial&nbsp;</li>
<li><a href="#mvFactorRefine"><span style="font-weight: bold; font-family: monospace; color: rgb(51, 51, 255);">mvFactorRefine</span></a>
---&nbsp; refine a coprime factorization of a polynomial</li>
<li><a href="#mvGCD"><span style="font-weight: bold; font-family: monospace; color: rgb(51, 51, 255);">mvGCD</span></a>
---&nbsp; compute the numerical GCD of two multivariate polynomials</li>
<li><a href="#mvGCDfixedDegree"><span style="font-weight: bold; font-family: monospace; color: rgb(51, 51, 255);">mvGCDfixedDegree</span></a>
---&nbsp; compute the numerical GCD of two multivariate polynomials
with a given GCD degree</li></ul>
</li>
</ul>
<h1><a name="Matrix_computation_functions"></a>Matrix
computation functions</h1>
<ul>
<li><a name="Major_LA_packages"></a>Major
packages<br>
<ul>
<li><a href="#ApproxiJordanForm"><span style="font-weight: bold; font-family: monospace; color: rgb(51, 51, 255);">NumericalJordanForm</span></a>
---&nbsp; compute the numerical Jordan Canonical Form of a complex
matrix even if entries are perturbed</li>
<li><a href="#ApproxiRank"><span style="font-weight: bold; font-family: monospace; color: rgb(51, 51, 255);">NumericalRank</span></a>
---&nbsp; compute the numerical rank, range and kernel of a matrix</li>
<li><a href="#ApproxiRankRowUpdate"><span style="font-weight: bold; font-family: monospace; color: rgb(51, 51, 255);">NumericalRankUpdate</span></a>
---&nbsp; update the numerical rank, range and kernel of a matrix
after inserting a row or column</li>
<li><a href="#ApproxiRankRowDowndate"><span style="font-weight: bold; font-family: monospace; color: rgb(51, 51, 255);">NumericalRankdowndate</span></a>
---&nbsp; update the numerical rank, range and kernel of a matrix
after deleting a row or column</li>
</ul>
</li>
</ul>
<ul>
<li><a name="LA_Programming_utilities"></a>Programming
utilities<br>
<ul>
<li><a href="#HouseholderVector"><span style="font-weight: bold; font-family: monospace; color: rgb(51, 51, 255);">HouseholderVector</span></a>
---&nbsp; generate a vector for the Househlder transformation</li>
<li><a href="#HouseholderTransform:"><span style="font-weight: bold; font-family: monospace; color: rgb(51, 51, 255);">HouseholderTransform</span></a>
---&nbsp; perform the Househlder transformation</li>
<li><a href="#HouseholderTransformRight"><span style="font-weight: bold; font-family: monospace; color: rgb(51, 51, 255);">HouseholderTransformRight</span></a>
---&nbsp; generate a vector for the Househlder transformation from
the right side</li>
<li><a href="#GivensMatrix"><span style="font-weight: bold; font-family: monospace; color: rgb(51, 51, 255);">GivensMatrix</span></a>
---&nbsp; generate a Givens' matrix</li>
<li><a href="#IntegerInverse:"><span style="font-weight: bold; font-family: monospace; color: rgb(51, 51, 255);">IntegerInverse</span></a>
---&nbsp; generate a random integer matrix with integer inverse</li>
<li><a href="#MatrixWithGivenJordanForm"><span style="font-weight: bold; font-family: monospace; color: rgb(51, 51, 255);">MatrixWithGivenJordanForm</span></a>
---&nbsp; generate a matrix with a given Jordan Canonical Form</li>
<li><a href="#NulVector"><span style="font-weight: bold; font-family: monospace; color: rgb(51, 51, 255);">NulVector</span></a>
---&nbsp; compute nullvectors of a matrix</li>
<li><a href="#ScaledLeastSquares"><span style="font-weight: bold; font-family: monospace; color: rgb(51, 51, 255);">ScaledLeastSquares</span></a>
---&nbsp; solve a scaled linear least squares problem</li>
</ul>
</li>
</ul>
<h1><a name="Relevant_publications"></a>Relevant publications</h1>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;<b><b><a href="mathcomp/zroot.pdf"><u><i><small><small><small><font size="5"><small><small><small></small></small></small></font></small></small></small></i></u></a></b></b><b><font size="1"><br></font></b>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b><b><a href="https://dl.acm.org/doi/10.1145/2576802.2576829"><u><i><small><small><small><font size="5"><small><small><small>NAClab: &nbsp;A Matlab toolbox for numerical algebraic computation</small></small></small></font></small></small></small></i></u></a><i><font size="4">,</font><font size="1">&nbsp;<big><big> </big></big></font></i><font size="1">Z. Zeng and T.Y, Li, <small><small>&nbsp;</small></small></font></b></b><small><small>ACM Comm. in Computer Algebra, (47) 2013, pp. 170-173</small></small><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<a href="https://doi.org/10.1007/978-3-319-96418-8_59"><span style="text-decoration: underline;"><span style="font-style: italic;"><span style="font-weight: bold;">Intuitive interface for solving linear and nonlinear system of equations</span></span></span></a><b><b><a href="https://doi.org/10.1007/978-3-319-96418-8_59"><u><i><small><small><small><font size="5"><small><small><small></small></small></small></font></small></small></small></i></u></a><i><font size="4">,</font><font size="1">&nbsp;<big><big> </big></big></font></i><font size="1">Z. Zeng, &nbsp;Proc. of&nbsp; ICMS 2018, 2018</font></b></b><small><small></small></small><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<b><b><a href="mathcomp/zroot.pdf"><u><i><small><small><small><font size="5"><small><small><small>C</small></small></small></font></small></small></small><font size="2">omputing multiple roots of inexact 
polynomials</font></i></u></a><i><font size="4">,</font><font size="1">&nbsp;<big><big> </big></big></font></i><font size="1">Z. Zeng, &nbsp; Mathematics of Computation, </font></b></b><b><font size="1">74(2005),&nbsp; 
pp 869 - 903</font></b><br><small><span style="font-weight: bold;"><small><small>&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;</small></small></span></small><b><b><a href="Papers/zrootpak.pdf"><u><span class="SpellE"><i><small><small><small><font size="5"><small><small><small>A</small></small></small></font></small></small></small><font size="2">lgorithm 835: 
MultRoot</font></i></span><font size="2"><i> -- A <span class="SpellE">Matlab</span> 
package for computing polynomial roots and 
multiplicities</i></font></u></a><i><font size="2">,</font><span style="font-size: 18pt;"></span></i></b></b><b><b><font size="1"><big> Z. Zeng, &nbsp;</big></font></b></b><b><b><i><span style="font-size: 18pt;"></span></i><font size="1">ACM Transaction 
on Mathematical Software,&nbsp;</font></b></b><b><font size="1">30(2004), pp 218-315<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; </font></b><a href="Papers/MultipleZeros.pdf"><b><u><i><small><small><small><font size="5"><small><small><small>M</small></small></small></font></small></small></small><font size="2">ultiple zeros of nonlinear systems</font></i></u></b></a><b><font size="1"> &nbsp;, &nbsp;&nbsp;</font></b><font size="1"><span style="font-weight: bold;">B.H. Dayton, T.-Y. Li and Z. Zeng, &nbsp;Mathematics of Computation, (80)2011, pp. 2143-2168<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; </span></font><a href="Papers/numfactor.pdf"><b><u><i><small><small><small><font size="5"><small><small><small>T</small></small></small></font></small></small></small><font size="2">he numerical factorization of polynomials</font></i></u></b></a><font size="1"><span style="font-weight: bold;">
&nbsp; W. Wu and Z. Zeng, Foundations of Computational Mathmatics, DOI
10.1007/s10208-015-9289-1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; </span></font><a href="Papers/eigit.pdf"><small><b><u><i>S</i></u></b></small></a><b><u><i><font><b><u><i><font size="2"><a href="Papers/eigit.pdf">ensitivity and computation of a defective eigenvalue </a>&nbsp;</font></i></u></b></font></i></u><i><font><b><i><font size="2"> &nbsp;<small><small>Z. Zeng</small></small>, &nbsp;preprint, &nbsp; </font></i></b></font></i><font><b><font size="2">[</font></b></font><a href="pseudoeig.html"><i><font><b><i><font size="2">Resources / Matlab codes</font></i></b></font></i></a><font><b><font size="2">] &nbsp;<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; </font></b></font></b><a href="Papers/ApCoaZeng.pdf"><b><u><i><small><small><small><font size="5"><small><small><small>R</small></small></small></font></small></small></small><font size="2">egularization and matrix computation in 
numerical polynomial algebra</font></i></u></b></a><small><small><a href="Papers/ApCoaZeng.pdf"> </a>&nbsp; Z. Zeng,</small></small><br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <a href="http://users.math.msu.edu/users/li/Recentworks_files/T.Y.Li.pdf"><b><u><i><small><small><small><font size="5"><small><small><small>Mixed volume &nbsp;computation. A revisit</small></small></small></font></small></small></small></i></u></b></a><small><small><a href="Papers/ApCoaZeng.pdf"> </a>&nbsp; T.-L. Lee &nbsp;and T..-Y. Li<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; </small></small><a href="http://users.math.msu.edu/users/li/Recentworks_files/HOM4PS-2.0.pdf"><b><u><i><small><small><small><font size="5"><small><small><small>HOM4PS-2.0: &nbsp;A software package for solving polynomial systems by the polyhedral homotopy continuation method</small></small></small></font></small></small></small></i></u></b></a><small><small><a href="http://users.math.msu.edu/users/li/Recentworks_files/HOM4PS-2.0.pdf"> &nbsp;</a> T.-L. Lee,&nbsp; T..-Y. Li and C.-H. Tsai &nbsp;<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; </small></small><a href="https://dl.acm.org/doi/10.1145/2513109.2513114"><b><u><i><small><small><small><font size="5"><small><small><small>Algorithm 931: An algorithm and software for computing multiplicity structure at zeros of nonlinear systems,</small></small></small></font></small></small></small></i></u></b></a><small><small>&nbsp; W. Hao, A.J. Sommese and Z. Zeng, &nbsp;ACM TOMS<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<span style="font-style: italic;"> </span></small><a style="font-weight: bold; font-style: italic;" href="apatools.pdf">ApaTools:&nbsp;
A software toolbox for approximate polynomial algebra</a></small><i>,&nbsp;
</i>Zhonggang Zeng, &nbsp;in <span style="font-size: 10pt;"><span style="font-style: italic;">Software
for Algebraic Geometry</span>, <span style="">&nbsp;</span>IMA
Volume 148, M.S.
Stillman et al. eds.,<span style="">&nbsp; </span>Springer,<span style="">&nbsp; </span>pp149-167,<span style="">&nbsp;
</span>2008</span><br><span style="text-decoration: underline;"><span style="font-style: italic;"><span style="font-weight: bold;"></span></span></span><br><font size="1"><span style="font-weight: bold;"></span></font><p><big><big><big><a name="download"></a>Download and installation: &nbsp; <br>&nbsp; &nbsp; 1. Download the <a href="https://github.com/StefanRickli/NAClab/blob/main/NAClab.zip">zip file</a> &nbsp; (<small>If your Matlab is older than 2013 edition, try <a href="https://web.archive.org/web/20210728230327/http://homepages.neiu.edu/~zzeng/NAClab/NAClab_pre2013.zip">this file</a> )</small><br>&nbsp; &nbsp; 2. Unzip and extract the .p and .m&nbsp; files in a folder, such as c:/NAClab<br>&nbsp; &nbsp; 3. Open Matlab and set path to the folder, e.g. &nbsp;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &gt;&gt; path(path,'c:/NAClab')</big></big></big></p><p><big><big><big>NAClab is then ready to go.</big></big></big></p><p></p><p><b><font face="Agency FB"><a href="https://web.archive.org/web/20210728230327/http://homepages.neiu.edu/%7Enaclab/#ScaledLeastSquares"><br>
</a></font></b></p>

<p><a name="Modules with brief explanations and examples"><font size="5"><b>M</b></font><font size="5"><b>odules
with brief explanations and examples</b></font></a></p>
<ul>
<li><b><font face="Agency FB" size="5"><a name="NulVector">NulVector</a></font></b><br>
The module for computing the smallest singular value of an
upper-triangular matrix along with the corresponding left and right
singular vectors. In many cases, it is desirable to determine if a
matrix is approximately rank-deficient without computing a full-blown
singular value decomposition. Module <b> <font face="Agency FB">NulVector</font></b>&nbsp;
is designed for this purpose. It also serves as a submodule
for&nbsp; <b> <font face="Agency FB">
ApproxiRank</font></b>&nbsp; that computes the
approximate rank and approximate kernel.<br>
<br>
<font face="Courier New">&nbsp;syntax:
&gt;&gt; LHS = RHS <br>
<br>
&nbsp; Input parameters: <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
R -- m</font><span style="font-family: Courier New;">x</span><font face="Courier New">n upper triangular matrix (m </font>â¥<font face="Courier New"> n) <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
theta -- (optional) the rank threshold <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
scale -- (optional) ||R||the rank threshold <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
m, n -- (optional) size of R <br>
<br>
&nbsp;Output parameters: <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
s -- an approximation to the smallest singular value<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
x -- the unit approximate null vector <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
y -- the unit left approximate null vector <br>
<br>
<b>Example:</b><br>
<br>
<font color="#008000" size="2">&gt;&gt;
A&nbsp; % </font><font size="2">a seemingly
full-rank matrix</font><font color="#008000" size="2"><br>
<br>
A =<br>
&nbsp;&nbsp;&nbsp; 1&nbsp; 10&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 0<br>
&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp; 1&nbsp;
10&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 0<br>
&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 1&nbsp; 10&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 0<br>
&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 1&nbsp;
10&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 0<br>
&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp;
1&nbsp; 10&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 0<br>
&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 1&nbsp; 10&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 0<br>
&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 1&nbsp;
10&nbsp;&nbsp; 0&nbsp;&nbsp; 0<br>
&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp;
1&nbsp; 10&nbsp;&nbsp; 0<br>
&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 1&nbsp; 10<br>
&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 1<br>
<br>
&gt;&gt; [s,x,y] = NulVector(A,1e-10);<br>
&gt;&gt;
s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
% </font><font size="2">the smallest singular value
is tiny:</font><font color="#008000" size="2"><br>
<br>
s =<br>
&nbsp;&nbsp; 9.900000000000001e-010<br>
<br>
&gt;&gt; [x,y]&nbsp; % </font><font size="2">the
right and left singular vectors</font><font color="#008000" size="2"><br>
<br>
ans =<br>
&nbsp;&nbsp;&nbsp;
-0.99498743710662&nbsp;&nbsp;&nbsp;&nbsp;
-0.00000000098504<br>
&nbsp;&nbsp;&nbsp;&nbsp;
0.09949874371066&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0.00000000994888<br>
&nbsp;&nbsp;&nbsp;
-0.00994987437107&nbsp;&nbsp;&nbsp;&nbsp;
-0.00000009949864<br>
&nbsp;&nbsp;&nbsp;&nbsp;
0.00099498743711&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0.00000099498743<br>
&nbsp;&nbsp;&nbsp;
-0.00009949874371&nbsp;&nbsp;&nbsp;&nbsp;
-0.00000994987437<br>
&nbsp;&nbsp;&nbsp;&nbsp;
0.00000994987437&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0.00009949874371<br>
&nbsp;&nbsp;&nbsp;
-0.00000099498743&nbsp;&nbsp;&nbsp;&nbsp;
-0.00099498743711<br>
&nbsp;&nbsp;&nbsp;&nbsp;
0.00000009949864&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0.00994987437107<br>
&nbsp;&nbsp;&nbsp;
-0.00000000994888&nbsp;&nbsp;&nbsp;&nbsp;
-0.09949874371066<br>
&nbsp;&nbsp;&nbsp;&nbsp;
0.00000000098504&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0.99498743710662<br>
<br>
&gt;&gt; [norm(A*x), norm(y'*A)]&nbsp; % </font><font size="2">verify them as approxi-nulvectors</font><font color="#008000" size="2"><br>
<br>
ans =<br>
&nbsp; 1.0e-009 *<br>
&nbsp;&nbsp;&nbsp; 0.99000000000001 0.99000000000001<br>
</font></font><br>
&nbsp;</li>
<li><b><font face="Agency FB" size="5"><a name="ApproxiRank">NumericalRank</a></font></b><br>
The function&nbsp; <b><font face="Agency FB">NumericalRank</font></b>&nbsp;
computes the numerical rank <i>rank<sub><font face="Times New Roman">Î¸</font></sub> </i>(<i>A</i>)
and the numerical kernel&nbsp; <i>K<font face="Times New Roman"><sub>Î¸</sub></font>
</i>(<i>A</i>)&nbsp; of a given
matrix&nbsp; <i>A</i> within a given rank
threshold&nbsp; <font face="Times New Roman">Î¸</font>.&nbsp;&nbsp;
The definitions of the approximate rank and approximate kernel are<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<i>rank<sub><font face="Times New Roman">Î¸</font></sub>
</i>(<i>A</i>)&nbsp; = the smallest rank of
all the matrix&nbsp; <i>B&nbsp; </i>&nbsp;such
that&nbsp; ||<i>B-A</i>|| &lt; <font face="Times New Roman">Î¸.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</font><i>K<sub><font face="Times New Roman">Î¸</font></sub>
</i>(<i>A</i>)&nbsp;&nbsp; =&nbsp;
the kernel of the matrix&nbsp; <i>B&nbsp; </i>that
is the nearest to&nbsp; <i>A</i>&nbsp; among all
matrices whose exact rank equals to <i>rank<sub><font face="Times New Roman">Î¸</font></sub> </i>(<i>A</i>).<br>
<span style="font-family: Courier New;"><br>
&nbsp;&nbsp; &lt;Syntax&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[r,Basis,C] = NumericalRank(A,tol,HL)<br>
&nbsp;<br>
&nbsp;&nbsp; &lt;Input Parameters&gt;<br>
&nbsp;&nbsp;&nbsp; 1.&nbsp;&nbsp; A -- the target
matrix;<br>
&nbsp;&nbsp;&nbsp; 2. tol -- (optional) the rank decision
threshold;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
default: tol = sqrt(n)*norm(A,1)*eps;<br>
&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp; HL -- (optional)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Set to 'high rank' if A is a high rank matrix. (default)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Set to 'low rank' if A is a low rank matrix.<br>
&nbsp;<br>
&nbsp;&nbsp; &lt;Output Parameters&gt;<br>
&nbsp;&nbsp;&nbsp; 1.
r&nbsp;&nbsp;&nbsp;&nbsp; -- the numerical rank of A;<br>
&nbsp;&nbsp;&nbsp; 2. Basis -- (optional)<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
For high rank cases...<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
a matrix whose columns form an orthonormal basis of<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
the numerical kernel;<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
For low rank cases...<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
a matrix whose columns form an orthonormal basis of<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
the numerical range;<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;
3.&nbsp;&nbsp;&nbsp;&nbsp; C -- (optional) Matlab cell
array contains information required<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
by updating/downdating;<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
For high rank cases...<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
C{1,1} = rank : the numerical rank of A;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
C{2,1} = Basis : matrix whose columns form an orthonormal kernel basis;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
C{3,1} = Q : the Q in the QR decomposition of the kernel stacked matrix;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
C{4,1} = R : the R in the QR decomposition of the kernel stacked matrix;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
C{5,1} = tau : the scaling factor in the kernel stacked matrix;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
C{6,1} = tol : the rank decision threshold;<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
For low rank cases...<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
C{1,1} = rank : the numerical rank of A;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
C{2,1} = U : U in the USV+E decomposition of A;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
C{3,1} = V : V in the USV+E decomposition of A;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
C{4,1} = S : S in the USV+E decomposition of A;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
C{5,1} = tol : the rank decision threshold;<br>
&nbsp;<br>
&nbsp;&nbsp; &lt;Reference&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp; [1] T.Y. Li and Z. Zeng, "A
Rank-Revealing Method with Updating, Downdating<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
and Applications", SIAM J. Matrix Anal. and Appl., 26 (2005), pp.
918--946.<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp; [2] T.L. Lee, T.Y. Li and Z.
Zeng, "A Rank-Revealing Method with Updating, <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Downdating and Applications, Part II", SIAM J. Matrix Anal. and Appl.
(2009).</span><br>
<br>
&nbsp;</li>
<li><b><font face="Agency FB" size="5"><a name="ApproxiRankRowUpdate">NumericalRankUpdate</a></font></b><br>
<font face="Courier New">&nbsp;&lt;Purpose&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Computing the
numerical rank of a updated matrix.<br>
&nbsp;<br>
&nbsp;&nbsp; &lt;Syntax&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [r,Basis,C] =
NumericalRankUpdate(A,pth,vec,C,RC)<br>
&nbsp;<br>
&nbsp;&nbsp; &lt;Input Parameters&gt;<br>
&nbsp;&nbsp;&nbsp; 1.&nbsp;&nbsp; A -- the target
matrix;<br>
&nbsp;&nbsp;&nbsp; 2. pth -- the index of row/column to be
inserted;<br>
&nbsp;&nbsp;&nbsp; 3. vec -- the row/column vector to be
inserted;<br>
&nbsp;&nbsp;&nbsp; 4.&nbsp;&nbsp; C -- cell array
contains information required by updating/downdating;<br>
&nbsp;&nbsp;&nbsp; 5.&nbsp; RC -- Set to 'row', then
the pth row will be inserted.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Set to 'column', then the pth column will be inserted.<br>
&nbsp;<br>
&nbsp;&nbsp; &lt;Output Parameters&gt;<br>
&nbsp;&nbsp;&nbsp; 1.
r&nbsp;&nbsp;&nbsp;&nbsp; -- the numerical rank of the
updated matrix;<br>
&nbsp;&nbsp;&nbsp; 2. Basis --<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
For high rank cases...<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
a matrix whose columns form an orthonormal basis of<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
the numerical kernel;<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
For low rank cases...<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
a matrix whose columns form an orthonormal basis of<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
the numerical range;<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;
3.&nbsp;&nbsp;&nbsp;&nbsp; C -- Matlab cell array<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; For high
rank cases...<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
C{1,1} = rank : the numerical rank of the updated matrix;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
C{2,1} = Basis : matrix whose columns form an orthonormal kernel basis;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
C{3,1} = Q : the Q in the QR decomposition of the kernel stacked matrix;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
C{4,1} = R : the R in the QR decomposition of the kernel stacked matrix;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
C{5,1} = tau : scaling factor in the kernel stacked matrix;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
C{6,1} = tol : the rank decision threshold;<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; For low
rank cases...<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
C{1,1} = rank : the numerical rank of the updated matrix;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
C{2,1} = U : the U in the USV+E decomposition of the updated matrix;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
C{3,1} = V : the V in the USV+E decomposition of the updated matrix;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
C{4,1} = S : the S in the USV+E decomposition of the updated matrix;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
C{5,1} = tol : the rank decision threshold;<br>
<br>
</font><br>
&nbsp;</li>
<li><b><font face="Agency FB" size="5"><a name="ApproxiRankRowDowndate">NumericalRankDowndate</a></font></b><br>
<span style="font-family: Courier New;">&nbsp;&nbsp;
&lt;Purpose&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Computing the
numerical rank of a downdated matrix.<br>
&nbsp;<br>
&nbsp;&nbsp; &lt;Syntax&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [r,Basis,C] =
NumericalRankDowndate(A,pth,C,RC)<br>
&nbsp;<br>
&nbsp;&nbsp; &lt;Input Parameters&gt;<br>
&nbsp;&nbsp;&nbsp; 1.&nbsp;&nbsp; A -- the target
matrix;<br>
&nbsp;&nbsp;&nbsp; 2. pth -- the index of row/column to be
deleted;<br>
&nbsp;&nbsp;&nbsp; 3.&nbsp;&nbsp; C -- cell array
contains information required by updating/downdating;<br>
&nbsp;&nbsp;&nbsp; 4.&nbsp; RC -- Set to 'row', then
the pth row will be deleted.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Set to 'column', then the pth column will be deleted.<br>
&nbsp;<br>
&nbsp;&nbsp; &lt;Output Parameters&gt;<br>
&nbsp;&nbsp;&nbsp; 1.
r&nbsp;&nbsp;&nbsp;&nbsp; -- the numerical rank of the
downdated matrix;<br>
&nbsp;&nbsp;&nbsp; 2. Basis --<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
For high rank cases...<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
a matrix whose columns form an orthonormal basis of<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
the numerical kernel;<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
For low rank cases...<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
a matrix whose columns form an orthonormal basis of<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
the numerical range;<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;
3.&nbsp;&nbsp;&nbsp;&nbsp; C -- Matlab cell array<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; For high
rank cases...<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
C{1,1} = rank : the numerical rank of the downdated matrix;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
C{2,1} = Basis : matrix whose columns form an orthonormal kernel basis;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
C{3,1} = Q : the Q in the QR decomposition of the kernel stacked matrix;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
C{4,1} = R : the R in the QR decomposition of the kernel stacked matrix;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
C{5,1} = tau : scaling factor in the kernel stacked matrix;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
C{6,1} = tol : the rank decision threshold;<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; For low
rank cases...<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
C{1,1} = rank : the numerical rank of the downdated matrix;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
C{2,1} = U : the U in the USV+E decomposition of the downdated matrix;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
C{3,1} = V : the V in the USV+E decomposition of the downdated matrix;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
C{4,1} = S : the S in the USV+E decomposition of the downdated matrix;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
C{5,1} = tol : the rank decision threshold;<br>
</span><font face="Courier New"><br>
<br>
&nbsp;</font></li>
<li><b><font face="Agency FB" size="5"><a name="ApproxiJordanForm">NumericalJordanForm</a></font></b><font face="Courier New"><br>
Computing a numerical Jordan decomposition<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<i>X</i>*<i>J</i>*inv(<i>X</i>)<br>
of a given matrix A within a distance threshold theta, formulated under
a 'three-strikes principle'. For details, see<br>
<br>
&nbsp;&nbsp;&nbsp; Z. Zeng and T.Y. Li, A numerical
algorithm for computing the Jordan<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Canonical Form, preprint, 2007<br>
<br>
In a nutshell, let <i>A</i> be a matrix whose entries are
given approximately <br>
with error magnitude being small. The exact JCF of <i>A</i>&nbsp;
will be degraded.<br>
However, it is possible to recover the underlying Jordan structure and<br>
approximate <i>X</i> and <i>J</i> by
NumericalJoranForm<br>
<br>
Syntax: There are several choices for either LHS or RHS<br>
&nbsp;&nbsp;&nbsp;
&gt;&gt;&nbsp;&nbsp;&nbsp;
LHS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
=&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RHS<br>
------------------- | --------------------------------------<br>
&nbsp;&nbsp;&nbsp;&nbsp;
[J,X]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|&nbsp;&nbsp; NumericalJordanForm(A)<br>
&nbsp;&nbsp;&nbsp;&nbsp;
[J,X,e,s,t]&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;
NumericalJordanForm(A,theta)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|&nbsp;&nbsp; NumericalJordanForm(A,theta,tau,gap)<br>
<br>
Input:&nbsp;&nbsp; A -- matrix whose AJCF is to be computed<br>
&nbsp;&nbsp;&nbsp;&nbsp; theta -- (optional) distance
threshold<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tau --
(optional) deflation threshold, simple eigenvalues<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
whose geometric condition numbers above tau will be deflated<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gap --
(optional) singular value gap used in rank revealing<br>
<br>
Output: J -- The Approximate Jordan Canonical Form<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
X -- The principle vector matrix<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
e -- the list of distinct eigenvalues<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
s -- The Jordan block sizes of the eigenvalues<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
t -- the residuals (backward errors) and the staircase condition<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
numbers of the eigenvalues<br>
<br>
Example:&nbsp; One can construct a test matrix with a given Jordan
Form by<br>
<br>
<font color="#008000" size="2">&gt;&gt;&nbsp;
A = MatrixWithGivenJordanForm([2 3],{[3 2 1], [2 2]})<br>
A =<br>
&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;
5&nbsp;&nbsp; 0&nbsp; -3&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp; -1&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp; -2<br>
&nbsp; -10&nbsp;&nbsp; 1&nbsp; 10&nbsp;&nbsp;
0&nbsp;&nbsp; 9&nbsp;&nbsp; 0&nbsp;&nbsp;
1&nbsp; -4&nbsp; -3&nbsp;&nbsp; 0<br>
&nbsp;&nbsp; -2&nbsp;&nbsp; 5&nbsp;&nbsp;
2&nbsp; -3&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;
-1&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp; -2<br>
&nbsp; -17&nbsp;&nbsp; 0&nbsp; 16&nbsp;&nbsp;
1&nbsp; 15&nbsp;&nbsp; 0&nbsp;&nbsp; 1&nbsp;
-7&nbsp; -5&nbsp; -1<br>
&nbsp;&nbsp;&nbsp; 6&nbsp; -1&nbsp;
-5&nbsp;&nbsp; 1&nbsp; -3&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 3&nbsp;&nbsp;
2&nbsp;&nbsp; 1<br>
&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 2&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 0<br>
&nbsp;&nbsp; -7&nbsp; -2&nbsp;&nbsp;
7&nbsp;&nbsp; 0&nbsp;&nbsp; 6&nbsp;&nbsp;
0&nbsp;&nbsp; 4&nbsp; -2&nbsp; -2&nbsp;&nbsp; 0<br>
&nbsp;&nbsp;&nbsp; 6&nbsp;&nbsp; 0&nbsp;
-6&nbsp;&nbsp; 0&nbsp; -6&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 6&nbsp;&nbsp;
2&nbsp;&nbsp; 0<br>
&nbsp;&nbsp;&nbsp; 9&nbsp; -3&nbsp;
-6&nbsp;&nbsp; 3&nbsp; -6&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 3&nbsp;&nbsp;
5&nbsp;&nbsp; 3<br>
&nbsp;&nbsp; 10&nbsp; -7&nbsp; -6&nbsp;&nbsp;
5&nbsp; -6&nbsp;&nbsp; 0&nbsp;&nbsp;
1&nbsp;&nbsp; 3&nbsp;&nbsp; 2&nbsp;&nbsp; 6</font><br>
<br>
Its AJCF can be computed as follows:<br>
<br>
<font color="#008000" size="2">&gt;&gt;
[J,X,e,s,t] = NumericalJordanForm(A);<br>
&gt;&gt; J<br>
<br>
J =<br>
&nbsp;&nbsp; 3.0000&nbsp; 1.0835&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<br>
&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
3.0000&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<br>
&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
3.0000&nbsp; 0.9464&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<br>
&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
3.0000&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<br>
&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
2.0000&nbsp; 0.6457&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<br>
&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.0000
-3.5426&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<br>
&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
2.0000&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<br>
&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.0000
-1.1010&nbsp; 0<br>
&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
2.0000&nbsp; 0<br>
&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.0000</font><br>
<br>
The distinct eigenvalues:<br>
<br>
<font color="#008000" size="2">&gt;&gt;
e<br>
<br>
e =<br>
&nbsp;&nbsp;&nbsp; 3.0000<br>
&nbsp;&nbsp;&nbsp; 2.0000<br>
</font><br>
The Jordan block sizes<br>
<br>
<font color="#008000" size="2">&gt;&gt;
s<br>
<br>
s =<br>
&nbsp;&nbsp;&nbsp; 2&nbsp; 2&nbsp; 0<br>
&nbsp;&nbsp;&nbsp; 3&nbsp; 2&nbsp; 1</font><br>
<br>
The backward error of the multiple eigenvalues<br>
<br>
<font color="#008000" size="2">&gt;&gt;
t(:,1)<br>
<br>
ans =<br>
<br>
1.0e-016 *<br>
<br>
&nbsp;&nbsp;&nbsp; 0.4897<br>
&nbsp;&nbsp;&nbsp; 0.6711</font><br>
<br>The backward error of the Jordan decomposition X*J*inv(X)<br><br>&gt;&gt; norm(A-X*J*inv(X))<br><br>ans =<br><br>&nbsp;&nbsp;&nbsp;&nbsp; 1.488853685812562e-13<br><br>
The staircase condition numbers<br>
<br>
<font color="#008000" size="2">&gt;&gt;
t(:,2)<br>
<br>
ans =<br>
<br>
33.5184<br>
78.4598</font><br>
&nbsp;</font></li>
<li><b><font face="Agency FB" size="5"><a name="uvGCD">uvGCD</a></font></b><br>
Computing the <i>approximate</i> greatest common divisor
(AGCD) of a univariate polynomial pair (<i>f,g</i>) within
a distance threshold<font face="Symbol"> q, </font>denoted
by&nbsp; <i>u=GCD<sub><font face="Symbol">q</font></sub></i>(<i>f,g</i>).&nbsp;
<br>
<br>
Computing exact GCD is an ill-posed problem whose solution will
generically degrade drastically by a tiny perturbation on the given
polynomial coefficients.&nbsp; The AGCD is, on the other hand,
continuously dependent on the problem data, and&nbsp; <b><font face="Agency FB">uvGCD</font></b>&nbsp; can
accurately computes the underlying GCD even if the given polynomial
pair is inexact.&nbsp; <br>
<br>
<b>The choice of parameter </b><font face="Symbol"><b>q</b>:</font>&nbsp;
Let (<i>f,g</i>) be the given polynomial pair that
approximates an underlying pair (<i>p,q</i>) whose GCD is
to be computed.&nbsp; Then the threshold <font face="Symbol">q
</font>needs to
satisfy&nbsp;&nbsp;&nbsp;&nbsp; ||(<i>f,g</i>)
- (<i>p,q</i>)||&nbsp; &lt; <font face="Symbol">q
&lt; t </font>&nbsp; where <font face="Symbol">t</font>&nbsp;
is the distance from&nbsp; (<i>f,g</i>)&nbsp; to
the nearest polynomial pair (<i>r,s</i>) whose GCD has a
higher degree.&nbsp; In other words, the lower bound of <font face="Symbol">q</font>&nbsp; is the magnitude of
data error and the upper bound is generally an unknown
number.&nbsp; The rule of thumb is that to choose&nbsp; <font face="Symbol">q</font>&nbsp; slightly larger than
the magnitude of data error.&nbsp; For example, if the coefficients
of (<i>f,g</i>) are accurate to around machine precision
(2.2e-16),&nbsp; then it is likely safe to set&nbsp; <font face="Symbol">q </font>&nbsp;= 1e-10.
<p align="left">See the reference:&nbsp; Zhonggang
Zeng,&nbsp; <i> <a href="uvgcd.pdf">The
approximate GCD of inexact polynomials, I: a univariate algorithm</a>,
</i>Preprint (2004)</p>
<p align="left"><b>Example</b>:</p>
<p align="left"><font color="#008000" face="Courier New" size="2">&gt;&gt; f<br>
<br>
f =<br>
&nbsp;&nbsp;&nbsp; 3 8 14 20 11 4<br>
<br>
&gt;&gt; g<br>
<br>
g =<br>
&nbsp;&nbsp;&nbsp; 5 14 26 40 30 20 11 4</font></p>
<p align="left"><font color="#008000" face="Courier New" size="2">&gt;&gt;
[u,v,w,res,cond] = uvGCD(f,g,1.0e-10)<br>
<br>
u =<br>
&nbsp;&nbsp;&nbsp; 8.30662386291807<br>
&nbsp;&nbsp;&nbsp; 16.61324772583615<br>
&nbsp;&nbsp;&nbsp; 24.91987158875423<br>
&nbsp;&nbsp;&nbsp; 33.22649545167231<br>
<br>
v =<br>
&nbsp;&nbsp;&nbsp; 0.36115755925731<br>
&nbsp;&nbsp;&nbsp; 0.24077170617154<br>
&nbsp;&nbsp;&nbsp; 0.12038585308577<br>
<br>
w =<br>
&nbsp;&nbsp;&nbsp; 0.60192926542885<br>
&nbsp;&nbsp;&nbsp; 0.48154341234308<br>
&nbsp;&nbsp;&nbsp; 0.36115755925731<br>
&nbsp;&nbsp;&nbsp; 0.24077170617154<br>
&nbsp;&nbsp;&nbsp; 0.12038585308577<br>
<br>
res =<br>
&nbsp;&nbsp;&nbsp; 1.614869854000228e-016<br>
<br>
cond =<br>
&nbsp;&nbsp;&nbsp; 45.53195717395850</font><font size="2"><br>
&nbsp;</font></p>
<p align="left"><font size="2">Here,&nbsp;&nbsp;
the syntax:&nbsp;&nbsp; &gt;&gt;
<font face="Courier New">[u, v, w,res, cond] =
uvGCD(f,g,theta)</font></font></p>
<p align="left"><font size="2">Input:</font></p>
<p align="left"><font face="Courier New" size="2">&nbsp;f, g&nbsp; -- coefficient vectors of
polynomial f and g<br>
theta&nbsp; -- tolerance within which maximum degree GCD is sought</font></p>
<p align="left"><font size="2">Output:</font></p>
<p align="left"><font face="Courier New" size="2">u&nbsp;&nbsp;&nbsp; --&nbsp; the
approximate GCD<br>
v&nbsp;&nbsp;&nbsp; --&nbsp; the cofactor for f<br>
w&nbsp;&nbsp;&nbsp; --&nbsp; the cofactor for g<br>
res&nbsp; -- the backward error, or residual<br>
cond -- the condition number of the approximate GCD</font></p>
<p><font face="Symbol"><br>
</font><font face="Times New Roman">More
specifically,&nbsp; for given&nbsp; </font>(<i>f,g</i>)<font face="Times New Roman"> and </font> <font face="Symbol">q</font><font face="Times New Roman">,&nbsp;
the module </font><font face="Arial Narrow">uvGCD</font><font face="Times New Roman"> calculates a triplet (<i>u,v,w</i>)
of polynomials satisfying the following "three-strikes" principles:<br>
&nbsp;&nbsp;&nbsp;&nbsp; (a)&nbsp; <u>Backward
nearness</u>:&nbsp;&nbsp; ||</font>(<i>f,g</i>)
- <font face="Times New Roman">(<i>uv,uw</i>)||
&lt; </font><font face="Symbol">q</font><font face="Times New Roman"> <br>
&nbsp;&nbsp;&nbsp;&nbsp; (b)&nbsp; <u>Maximum
co-dimension</u>:&nbsp; Polynomial pairs (<i>uv,uw</i>)
belongs to the manifold</font><font face="Symbol">&nbsp;
P</font><sub>k</sub><font face="Symbol">&nbsp;
= </font> <font face="Times New Roman">{</font>(<i>p,q</i>)
| GCD(<i>p,q</i>) is of degree<i> k</i>}&nbsp;
that has the highest co-dimension amoung all such manifolds
intersecting the <font face="Symbol">q-</font>neighborhood
of (<i>f,g</i>).<br>
&nbsp;&nbsp;&nbsp;&nbsp; (c)&nbsp; <u>Minimum
distance:</u>&nbsp; The pair <font face="Times New Roman">(<i>uv,uw</i>)
is the nearest to </font>(<i>f,g</i>)<font face="Times New Roman"> amoung all polynomial pairs in </font><font face="Symbol">P</font><sub>k</sub><font face="Times New Roman">.<br>
The polynomial&nbsp;&nbsp; <i>u=GCD</i>(<i>uv,uw</i>)&nbsp;
is called an AGCD of&nbsp; </font>(<i>f,g</i>). <br>
<br>
&nbsp;</p>
</li>
<li><b><font face="Agency FB" size="5"><a name="ExtendedGCD">ExtendedGCD</a></font></b><br>
ExtendedGCD computes the extended GCD in approximate sense.&nbsp;
For a given polynomial pair (f,g), it computes a polynomial pair
(p,q)&nbsp; such that&nbsp;&nbsp; <i>p f + qg</i>
= <i>GCD</i>(<i>f,g</i>)&nbsp; in
approximate sense.<br>
<br>
<font face="Courier New">Calling
syntax:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt; [p, q] = ExtendedGCD(v,w);<br>
<br>
Input:&nbsp; v, w -- approximate cofactors, as in the output of<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt;[u,v,w] = uvGCD(f,g,tol)<br>
<br>
Output&nbsp; p, q -- polynomials such that p*f+q*g = GCD(f,g)
approximately</font><br>
<br>
<b>Example:</b><br>
<br>
<font color="#008000"><font face="Courier New" size="2">&gt;&gt; f = [3 8 14 20 11
4];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
% set polynomials f and g<br>
&gt;&gt; g = [5 14 26 40 30 20 11 4];<br>
&gt;&gt; [u,v,w,res,cond] = uvGCD(f,g); % calculate the GCD
triplet (u,v,w)<br>
&gt;&gt; [p,q] =
ExtendedGCD(v,w)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
% calculate the extended GCD using v and w<br>
<br>
p =<br>
&nbsp;&nbsp;&nbsp; -4.75485272428887<br>
&nbsp;&nbsp;&nbsp; -0.98068837438458<br>
&nbsp;&nbsp;&nbsp; -0.89153488580416<br>
&nbsp;&nbsp;&nbsp; -1.18871318107222<br>
<br>
q =<br>
&nbsp;&nbsp;&nbsp; 2.85291163457332<br>
&nbsp;&nbsp;&nbsp; 0.20802480668764<br>
</font><font size="2"><br>
</font><font face="Courier New" size="2">&gt;&gt;
h = conv(p,f)+conv(q,g);&nbsp;&nbsp;&nbsp; % compute p*f+q*g<br>
&gt;&gt; h'<br>
<br>
ans =<br>
&nbsp;&nbsp;&nbsp; 0.00000000000000<br>
&nbsp;&nbsp;&nbsp; 0.00000000000001<br>
&nbsp;&nbsp;&nbsp; 0<br>
&nbsp;&nbsp;&nbsp; 0.00000000000001<br>
&nbsp;&nbsp;&nbsp; 0<br>
&nbsp;&nbsp; -0.98068837438458<br>
&nbsp;&nbsp; -1.96137674876916<br>
&nbsp;&nbsp; -2.94206512315374<br>
&nbsp;&nbsp; -3.92275349753832<br>
<br>
&gt;&gt;
u&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
% compare with u=GCD(f,g)<br>
<br>
u =<br>
&nbsp;&nbsp; -0.98068837438458<br>
&nbsp;&nbsp; -1.96137674876916<br>
&nbsp;&nbsp; -2.94206512315374<br>
&nbsp;&nbsp; -3.92275349753832<br>
&nbsp;</font></font></li>
<li><b><font face="Agency FB" size="5"><a name="uvFactor">uvFactor</a></font></b><br>
The module&nbsp; uvFactor&nbsp; computes an approximate
factorization&nbsp;&nbsp;&nbsp; <i><font size="4">&nbsp;</font></i><font size="4">(<i>a</i></font><i><sub>1</sub><font size="4"> x&nbsp; -&nbsp; b</font><sub>1</sub></i><font size="4"> )</font><i><sup><font size="5">m</font></sup><font size="1">1</font><sup> </sup></i>&nbsp;
<font size="4">(<i>a</i></font><i><sub>2</sub><font size="4"> x&nbsp; -&nbsp; b</font></i><sub><i>2</i></sub><font size="4"> )</font><i><sup><font size="5">m</font></sup><font size="1">2</font><sup> </sup></i>&nbsp;
... <font size="4">(<i>a</i></font><i><sub>k</sub><font size="4"> x&nbsp; -&nbsp; b</font></i><sub><i>k</i></sub><font size="4"> )</font><i><sup><font size="5">m</font></sup><font size="1">k</font><sup> </sup></i>&nbsp;&nbsp;&nbsp;
of a given polynomial&nbsp; <i>f</i>(<i>x</i>)&nbsp;
within a given tolerance&nbsp; <font face="Times New Roman">Î¸&nbsp;
for data perturbation.&nbsp; <br>
<br>
When the coefficients of&nbsp; </font><i>f</i>(<i>x</i>)&nbsp;
are approximate (inexact) and the multiplicities&nbsp; <i>m<sub>j</sub>'</i>s
are nontrivial, finding such a factorization has been a long standing
challenge in numerical computation since the factorization problem in
exact sense is ill-posed.&nbsp; Namely, a tiny perturbation on the
coefficients of the given polynomial&nbsp; <i>f&nbsp; </i>almost
always degrades the accuracy of the factors and multiplicities
drastically.&nbsp;&nbsp; The module&nbsp; <font face="Arial Narrow">uvFactor </font>&nbsp;in <font face="Arial Narrow">&nbsp;</font><b><font face="Agency FB">NAClab</font></b>,&nbsp;
however, is designed to calculate the factors and multiplicities
accurately even if the input polynomial is perturbed. <br>
<br>
<font face="Courier New">Syntax:&nbsp;
&gt;&gt; [F,res] = uvFactor(f, theta )<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt; [F,res] = uvFactor(f, theta, 1 )<br>
<br>
Input:&nbsp;&nbsp;&nbsp;&nbsp; p -- coefficient vector
of the polynomial to be factored<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
tol -- (optional) backward error tolerance<br>
&nbsp;&nbsp; showroots -- (optional, 0 or 1) showing roots or
not<br>
<br>
Output&nbsp;&nbsp;&nbsp;&nbsp; F -- kx3 matrix
containing factors with<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
each row [</font><i>a<sub>i</sub> , b<sub>i</sub>
,m<sub>i</sub> </i> <font face="Courier New">]
representing a factor <font size="4">(</font></font><font size="4"><i>a<sub>i</sub>x + b<sub>i</sub></i></font><font face="Courier New" size="4">)</font><i><sup><font size="5">m</font></sup></i><font size="1"><i>i</i></font><br>
<br>
<b>Example</b>:&nbsp;&nbsp; We construct
polynomial&nbsp;&nbsp;&nbsp; <i>p</i>(<i>x</i>)&nbsp;
=&nbsp; (<i> x-</i>1 )<sup>40 </sup>&nbsp;(<i>
x-</i>2 )<sup>30</sup> (<i> x-</i>3 )<sup>20</sup>&nbsp;
(<i> x-</i>4 )<sup>10</sup>&nbsp;&nbsp;&nbsp;
with coefficients round to 16 digits.<br>
<font face="Courier New"><br>
<font color="#008000"><font size="2">&gt;&gt;
p = poly([ones(1,40),2*ones(1,30),3*ones(1,20),4*ones(1,10)]);<br>
&gt;&gt; [F,res] = uvFactor(p,1e-9)<br>
<br>
F =<br>
&nbsp;&nbsp;&nbsp; 0.51445747892761&nbsp;&nbsp;
-2.05782991571042&nbsp;&nbsp; 10.00000000000000<br>
&nbsp;&nbsp;&nbsp; 0.67077048679987&nbsp;&nbsp;
-2.01231146039961&nbsp;&nbsp; 20.00000000000000<br>
&nbsp;&nbsp;&nbsp; 0.94861271967198&nbsp;&nbsp;
-1.89722543934395&nbsp;&nbsp; 30.00000000000000<br>
&nbsp;&nbsp;&nbsp; 1.49988840579248&nbsp;&nbsp;
-1.49988840579248&nbsp;&nbsp; 40.00000000000000<br>
<br>
<br>
res =<br>
&nbsp;&nbsp;&nbsp; 8.584956337989512e-016</font><br>
</font><br>
</font>The roots and multiplicities can be shown by<font face="Courier New"><br>
<br>
<font color="#008000" size="2">&gt;&gt;
[-F(:,2)./F(:,1),F(:,3)]<br>
<br>
ans =<br>
<br>
&nbsp;&nbsp;&nbsp;
4.00000000000002&nbsp;&nbsp;&nbsp; 10.00000000000000<br>
&nbsp;&nbsp;&nbsp;
2.99999999999998&nbsp;&nbsp;&nbsp; 20.00000000000000<br>
&nbsp;&nbsp;&nbsp;
2.00000000000001&nbsp;&nbsp;&nbsp; 30.00000000000000<br>
&nbsp;&nbsp;&nbsp;
1.00000000000000&nbsp;&nbsp;&nbsp; 40.00000000000000</font><br>
<br>
</font>Or, use the root-showing flag parameter<font face="Courier New"><br>
<br>
<font size="2"><font color="#008000">&gt;&gt;
[F,res] = uvFactor(p,1e-9,1);</font><br>
<font color="#008000"><br>
THE CONDITION NUMBER: 6.70133 <br>
THE BACKWARD ERROR: 3.51e-015 <br>
THE ESTIMATED FORWARD ROOT ERROR: 4.70e-014 <br>
<br>
FACTORS <br>
<br>
&nbsp;&nbsp;&nbsp; ( x - 3.999999999999993 )^10<br>
&nbsp;&nbsp;&nbsp; ( x - 3.000000000000007 )^20<br>
&nbsp;&nbsp;&nbsp; ( x - 1.999999999999998 )^30<br>
&nbsp;&nbsp;&nbsp; ( x - 1.000000000000000 )^40</font></font><font color="#008000"><br>
&nbsp;</font></font></li>
<li><b><a name="mvGCD"><font face="Agency FB" size="5">mvGCD</font></a></b><br>
Computing the <i>approximate</i> greatest common divisor
(AGCD) of a multivariate polynomial pair (<i>f,g</i>)
within a distance threshold<font face="Symbol"> q, </font>denoted
by&nbsp; <i>u=GCD<sub><font face="Symbol">q</font></sub></i>(<i>f,g</i>).&nbsp;
<br>
<br>
Computing exact GCD is an ill-posed problem whose solution will
generically degrade drastically by a tiny perturbation on the given
polynomial coefficients.&nbsp; The AGCD is, on the other hand,
continuously dependent on the problem data, and&nbsp; <font face="Arial Narrow">mvGCD</font>&nbsp; can
accurately computes the underlying GCD even if the given polynomial
pair is inexact.&nbsp; <br>
<br>
<b>The choice of parameter </b><font face="Symbol"><b>q</b>:</font>&nbsp;
Let (<i>f,g</i>) be the given polynomial pair that
approximates an underlying pair (<i>p,q</i>) whose GCD is
to be computed.&nbsp; Then the threshold <font face="Symbol">q
</font>needs to
satisfy&nbsp;&nbsp;&nbsp;&nbsp; ||(<i>f,g</i>)
- (<i>p,q</i>)||&nbsp; &lt; <font face="Symbol">q
&lt; t </font>&nbsp; where <font face="Symbol">t</font>&nbsp;
is the distance from&nbsp; (<i>f,g</i>)&nbsp; to
the nearest polynomial pair (<i>r,s</i>) whose GCD has a
higher degree.&nbsp; In other words, the lower bound of <font face="Symbol">q</font>&nbsp; is the magnitude of
data error and the upper bound is generally an unknown
number.&nbsp; The rule of thumb is that to choose&nbsp; <font face="Symbol">q</font>&nbsp; slightly larger than
the magnitude of data error.&nbsp; For example, if the coefficients
of (<i>f,g</i>) are accurate to around machine precision
(2.2e-16),&nbsp; then it is likely safe to set&nbsp; <font face="Symbol">q </font>&nbsp;= 1e-10.
<p align="left"><b>Reference</b>:&nbsp;
Z. Zeng and B.H. Dayton,&nbsp; <i><a href="http://homepages.neiu.edu/%7Ezzeng/mvgcd.pdf">The
approximate GCD of inexact polynomials, II: a multivariate algorithm</a>,
</i>Proc. of ISSAC 04, pp320-327, 2004.</p>
<p class="MsoNormal" style="text-indent: 0.25in;"><font face="Courier New">Syntax:&nbsp;&nbsp;&nbsp;
&gt;&gt; [<span class="SpellE">u<span class="GramE">,v,w,res,cond</span></span>] = <span class="SpellE">mvGCD</span>(p,
q, <span class="SpellE">theta</span>, ctrl)</font></p>
<p class="MsoNormal" style="text-indent: 0.25in;"><font face="Courier New"><span class="GramE">where<br>
</span><span style="">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Input:<span style="">&nbsp;&nbsp;
</span>p,
q<span style=""> </span>---
coefficient matrices of p and q<br>
<span style="">&nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp;&nbsp; </span><span style="">&nbsp;</span><span style="">theta
</span>---<span style=""></span>(optional)
the
residual tolerance<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span><span class="GramE">ctrl</span><span style=""></span>---<span style=""></span>(optional)
control parameter, <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if ctrl = 1 then refinement will be
performed. <br>
<span style="">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span><span class="GramE">otherwise</span>
the code stops without refinement. <br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Output:&nbsp;&nbsp;&nbsp;&nbsp; u --- the AGCD of p and
q<br>
<span style="">&nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</span><span class="GramE"> v</span>, w<span style="">
</span>--- the co-factors<br>
<span style="">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span><span class="SpellE"><span class="GramE">res</span></span><span style="">
</span>--- the residual<br>
<span style="">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span><span class="SpellE"><span class="GramE">c ond</span></span><span style=""> </span>--- the AGCD condition number (if
ctrl = 1 ).<br>
<br>
&nbsp;</font></p>
<span style="">
<p class="MsoNormal">Example:<o:p></o:p></p>
<span style="">
<p class="MsoNormal"><span style="font-size: 10pt; font-family: &quot;Courier New&quot;;"><font color="#008000"><span style="">f
=<br>
<span style="">&nbsp; &nbsp;&nbsp; </span>0&nbsp;<span style=""></span>1&nbsp;<span style=""></span>
2 &nbsp;<span style=""></span>3<span style="">
</span>4<span style=""> &nbsp;</span>0&nbsp;<span style=""></span>1&nbsp;<span style=""></span>
2 &nbsp;<span style=""></span>0&nbsp;<span style=""></span>1 &nbsp;<span style=""></span>2&nbsp;<span style=""></span>0<span style=""> </span><span class="SpellE">0</span></span><o:p><br>
</o:p><span style=""><span style="">&nbsp;
&nbsp;&nbsp; </span>0&nbsp;<span style=""></span><span class="SpellE">0</span> &nbsp;<span style=""></span><span class="SpellE">0</span>&nbsp;<span style=""></span><span class="SpellE"> 0</span>&nbsp;<span style=""></span><span class="SpellE">0</span><span style=""> </span>&nbsp;1&nbsp;<span style=""></span><span class="SpellE">1</span>&nbsp;<span style=""></span><span class="SpellE"> 1</span>&nbsp;<span style=""></span> 2&nbsp;<span style=""></span><span class="SpellE">2</span> &nbsp;<span style=""></span><span class="SpellE">2</span>&nbsp;<span style=""></span>3&nbsp;<span style=""></span>4</span><o:p><br>
</o:p><span style=""><span style="">&nbsp;
&nbsp;&nbsp; </span><span class="GramE">4<span style=""> </span><span class="SpellE">4</span></span>
-3 -2<span style=""> </span>1 12&nbsp;<span style=""></span>6&nbsp;<span style=""></span>-6&nbsp;<span style=""></span>13&nbsp;<span style=""></span>2
-2&nbsp;<span style=""></span>6&nbsp;<span style=""></span>1</span></font><o:p></o:p></span></p>
<p class="MsoNormal"><span style="font-size: 10pt; font-family: &quot;Courier New&quot;;">
<font color="#008000"><span style="">g
=<span style=""><br>
&nbsp; &nbsp;&nbsp; </span>0&nbsp;<span style=""></span> 1<span style="">&nbsp;
</span><span class="GramE">2<span style="">
</span>3</span><span style=""> </span>4<span style=""></span> &nbsp;0<span style="">
&nbsp;</span>1<span style=""> &nbsp;</span>2&nbsp;<span style=""></span>3<span style="">
&nbsp;</span>0 <span style="">&nbsp;</span>1&nbsp;<span style=""></span>2<span style=""> </span>0<span style=""> </span>1&nbsp;<span style=""></span>0</span><o:p><br>
</o:p><span style=""><span style="">&nbsp;
&nbsp;&nbsp; </span>0&nbsp;<span style=""></span><span class="SpellE"> 0</span> <span style="">&nbsp;</span><span class="SpellE"><span class="GramE">0</span></span><span class="GramE"><span style=""> </span><span class="SpellE">0</span></span><span style="">
</span><span class="SpellE">0</span> <span style="">&nbsp;</span>1<span style="">
&nbsp;</span><span class="SpellE">1</span>
<span style="">&nbsp;</span><span class="SpellE">1</span><span style=""> </span><span class="SpellE">1</span><span style="">&nbsp;
</span>2 <span style="">&nbsp;</span><span class="SpellE">2</span>&nbsp;<span style=""></span><span class="SpellE">2</span>&nbsp;<span style=""></span>3&nbsp;<span style=""></span><span class="SpellE">3</span>&nbsp;<span style=""></span>4</span><o:p><br>
</o:p><span style=""><span style="">&nbsp;
&nbsp;&nbsp; </span>4&nbsp;<span style=""></span>12&nbsp;<span style=""></span>13<span style=""> </span>6<span style=""> </span>1&nbsp;<span style=""></span>12&nbsp;<span style=""></span>26&nbsp;<span style=""></span>18&nbsp;<span style=""></span>4 13&nbsp;<span style=""></span>18&nbsp;<span style=""></span>6&nbsp;<span style=""></span><span class="SpellE">6</span>&nbsp;<span style=""></span>4&nbsp;<span style=""></span>1</span></font><o:p></o:p></span></p>
<span style=""><span style="font-family: &quot;Courier New&quot;; color: green;">&gt;&gt;
[u,v,w,res,cond] = mvGCD(f,g)<br>
<br>
u =<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp; 1.0000&nbsp;&nbsp;&nbsp;
2.0000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;
1.0000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;
1.0000&nbsp;&nbsp;&nbsp;
1.0000&nbsp;&nbsp;&nbsp; 2.0000<br>
&nbsp; -10.3923&nbsp; -20.7846&nbsp; -10.3923&nbsp;
-20.7846&nbsp; -20.7846&nbsp; -10.3923<br>
<br>
<br>
v =<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp; 1.0000&nbsp;&nbsp;&nbsp;
2.0000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;
1.0000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;
1.0000&nbsp;&nbsp;&nbsp;
1.0000&nbsp;&nbsp;&nbsp; 2.0000<br>
&nbsp;&nbsp;
-0.3849&nbsp;&nbsp;&nbsp; 0.3849&nbsp;&nbsp;
-0.0962&nbsp;&nbsp;
-0.3849&nbsp;&nbsp;&nbsp; 0.1925&nbsp;&nbsp; -0.0962<br>
<br>
<br>
w =<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp; 1.0000&nbsp;&nbsp;&nbsp;
2.0000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;
1.0000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;
1.0000&nbsp;&nbsp;&nbsp;
1.0000&nbsp;&nbsp;&nbsp; 2.0000<br>
&nbsp;&nbsp; -0.3849&nbsp;&nbsp;
-0.3849&nbsp;&nbsp; -0.0962&nbsp;&nbsp;
-0.3849&nbsp;&nbsp; -0.1925&nbsp;&nbsp; -0.0962<br>
<br>
<br>
res =<br>
<br>
&nbsp; 3.5527e-015<br>
<br>
<br>
cond =<br>
<br>
&nbsp;&nbsp;&nbsp; 1.4832</span><span style=""><span style=""><span style="">
<p class="MsoNormal"><span style="font-size: 10pt; font-family: &quot;Courier New&quot;;"><font color="#008000"><span style=""></span></font><o:p></o:p></span></p>
<p class="MsoNormal"><b style=""><o:p>&nbsp;</o:p></b></p>
</span></span></span></span></span></span></li>
<li><b><font face="Agency FB" size="5"><a name="SquarefreeFactor"> SquarefreeFactor</a></font></b><br>
For a given multivariate polynomial&nbsp; <i>p</i>,&nbsp;
the module&nbsp; <b> <font face="Agency FB">SquarefreeFactor</font></b>&nbsp;
computes a squarefree factorization <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<i><font size="5">p</font><sub>0</sub>&nbsp;
</i><font size="5">(</font><i><font size="5">p</font><sub>1</sub></i><font size="5">)</font><sup><i><font size="5">m</font><font size="1">1</font></i></sup> <i>&nbsp;</i><font size="5">(</font><i><font size="5">p</font></i><sub><i>2</i></sub><font size="5">)</font><sup><i><font size="5">m</font><font size="1">2</font></i></sup>&nbsp; <i>...</i>
<font size="5">(</font><i><font size="5">p</font></i><sub><i>k</i></sub><font size="5">)</font><sup><i><font size="5">m</font><font size="1">k</font></i></sup><br>
of&nbsp; <i>&nbsp;p&nbsp; </i>along with
multiplicities&nbsp; <i>m<sub>1</sub> , m<sub>2
</sub>, ... m<sub>k</sub>&nbsp; </i>accurately
even if the polynomial is perturbed.&nbsp;&nbsp; Here <i><font size="5">&nbsp;</font>p<sub>0</sub></i>&nbsp;
is a constant factor and&nbsp; <i>p<sub>j </sub>'</i>s
are nontrivial polynomial factors for&nbsp; <i>j</i>
&gt; 0. <br>
<br>
&nbsp;<font face="Courier New">Syntax:&nbsp;&nbsp;
&gt;&gt; [F,res,cond] = SquarefreeFactor(p,tol);<br>
<br>
&nbsp;Input&nbsp;&nbsp; p -- a multivariate polynomial (as
a coeff. matrix) to be factored<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tol --
(optional) backward error tolerance<br>
<br>
&nbsp;Output&nbsp; F -- cell of size kx2. For each j = 1, 2,
..., k, F{j,1}, F{j,2}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
are a squarefree factor and its multiplicity respectively<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res --
residual<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cond -- condition
number of the factorization<br>
<br>
Example:<br>
<br>
We construct a factorable polynomial<br>
<br>
<font color="#008000" size="2">&gt;&gt;
p = [2 1 0 0; 0 1 2 0; 1 1 -1 1];<br>
&gt;&gt; q = [3 0 3 0; 2 2 0 0; 1 1 -2 -2];<br>
&gt;&gt; r = [3 0 1 0; 0 3 2 0; 1 -1 -3 2];<br>
&gt;&gt; u = mvPolynPower(p,4);<br>
&gt;&gt; v = mvPolynPower(q,3);<br>
&gt;&gt; w = mvPolynMultiply(u,v);<br>
&gt;&gt; f = mvPolynMultiply(w,r);<br>
&gt;&gt; [F,res,cond] = SquarefreeFactor(f,1e-10)<br>
<br>
F = <br>
<br>
&nbsp;&nbsp;&nbsp; [3x1 double] [1]<br>
&nbsp;&nbsp;&nbsp; [3x4 double] [1]<br>
&nbsp;&nbsp;&nbsp; [3x4 double] [3]<br>
&nbsp;&nbsp;&nbsp; [3x4 double] [4]<br>
<br>
<br>
res =<br>
<br>
&nbsp;&nbsp;&nbsp; 9.094947017729282e-013<br>
<br>
<br>
cond =<br>
<br>
&nbsp;&nbsp;&nbsp; 0.00417001580803</font><br>
<br>
Factors can be retrieved as follows:<br>
<br>
<font color="#008000" size="2">&gt;&gt;
F{1,1}&nbsp; % the constant factor<br>
<br>
ans =<br>
<br>
&nbsp;&nbsp;&nbsp; 0<br>
&nbsp;&nbsp;&nbsp; 0<br>
&nbsp;&nbsp;&nbsp; 2.32164695714406<br>
<br>
&gt;&gt; F{2,1}&nbsp; % factor of multiplicity F{2,2} = 1<br>
<br>
ans =<br>
<br>
&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
3.00000000000000&nbsp; 1.00000000000000&nbsp; 0<br>
&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
2.00000000000000&nbsp; 3.00000000000000<br>
&nbsp;&nbsp; -1.19889333343897&nbsp;
-0.59944666671943&nbsp; 1.79834000015840&nbsp; 0.59944666671949<br>
<br>
&gt;&gt; F{3,1}&nbsp; % factor of multiplicity F{3,2} = 3<br>
<br>
ans =<br>
<br>
&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
3.00000000000000&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
3.00000000000000<br>
&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
2.00000000000000&nbsp;&nbsp; 2.00000000000000<br>
&nbsp;&nbsp;&nbsp; 1.46833846147498&nbsp;
1.46833846147490&nbsp; -0.73416923073738&nbsp; -0.73416923073740<br>
<br>
&gt;&gt; F{3,1}<br>
<br>
ans =<br>
<br>
&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
2.00000000000000&nbsp;&nbsp;
1.00000000000000&nbsp;&nbsp; 0<br>
&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
1.00000000000000&nbsp;&nbsp; 2.00000000000000<br>
&nbsp;&nbsp;&nbsp; 1.16082347857208&nbsp;
1.16082347857205&nbsp;&nbsp; 1.16082347857192&nbsp;
-1.16082347857206<br>
<br>
</font><br>
<br>
Even if one make a substantial perturbation, a squarefree factorization
can still be calculated up to the data accuracy: <br>
<br>
<font color="#008000" size="2">&gt;&gt;
g(3,:) = f(3,:)+1e-6*rand(1,size(f,2));&nbsp;&nbsp; % perturbed
polynomial<br>
&gt;&gt; [F,res,cond] = SquarefreeFactor(g,1e-4,1)<br>
<br>
F = <br>
<br>
&nbsp;&nbsp;&nbsp; [3x1 double] [1]<br>
&nbsp;&nbsp;&nbsp; [3x4 double] [1]<br>
&nbsp;&nbsp;&nbsp; [3x4 double] [3]<br>
&nbsp;&nbsp;&nbsp; [3x4 double] [4]<br>
<br>
<br>
res =<br>
<br>
&nbsp;&nbsp;&nbsp; 1.216959617522662e-006<br>
<br>
<br>
cond =<br>
<br>
&nbsp;&nbsp;&nbsp; 0.00417001629401<br>
<br>
&gt;&gt; F{2,1}<br>
<br>
ans =<br>
<br>
&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
3.00000000000000&nbsp; 1.00000000000000&nbsp; 0<br>
&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
2.00000000000000&nbsp; 3.00000000000000<br>
&nbsp;&nbsp; -1.19889332029971&nbsp;
-0.59944665012542&nbsp; 1.79834000569698&nbsp; 0.59944664442427</font><br>
<br>
<br>
&nbsp;</font></li>
<li><b><font face="Agency FB" size="5"><a name="mvFactorRefine">mvFactorRefine</a></font></b><font face="Courier New"><br>
For a given initial factorization (stored in F) <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font>&nbsp;&nbsp;
<i><font size="5">p</font><sub>0</sub>&nbsp;
</i><font size="5">(</font><i><font size="5">p</font><sub>1</sub></i><font size="5">)</font><sup><i><font size="5">m</font><font size="1">1</font></i></sup> <i>&nbsp;</i><font size="5">(</font><i><font size="5">p</font></i><sub><i>2</i></sub><font size="5">)</font><sup><i><font size="5">m</font><font size="1">2</font></i></sup>&nbsp; <i>...</i>
<font size="5">(</font><i><font size="5">p</font></i><sub><i>k</i></sub><font size="5">)</font><sup><i><font size="5">m</font><font size="1">k</font></i></sup><font face="Courier New"><br>
of multivariate polynomial </font><i><font size="4">p</font></i><font face="Courier New">, the module mvFactorRefine attempts to
improve the accuracy by applying the Gauss-Newton iteration module
GaussNewton. <br>
<br>
This module is used as a submodule for the module </font><b>
<font face="Agency FB">SquarefreeFactor</font></b><font face="Courier New">.&nbsp; <br>
<br>
<br>
Syntax: &gt;&gt;[G,res,cond] = mvFactorRefine(F, p);<br>
<br>
&nbsp;&nbsp; Input:&nbsp; F -- a kx2 cell containing the
factors and multiplicities of the <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
initial factorization of p. For each j = 1, 2, ..., k,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
F{j,1} is the j-th factor with multiplicity F{j,2}.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
p -- multivariate polynomial in coeff. matrix<br>
<br>
&nbsp;&nbsp; Output:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
G -- a cell containing the refined factors in the same format as F<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
res -- the residual, i.e., backward error of the factorization<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
cond -- the condition number of the factorization<br>
<br>
&nbsp;</font></li>
<li><b><font face="Agency FB" size="5"><a name="Polynomial2CoefficientMatrix">
Polynomial2CoefficientMatrix</a></font></b><br>
<span style="font-size: 10pt; font-family: &quot;Courier New&quot;;">&nbsp;&nbsp;
<b> convert a polynomial to coefficient matrix<br>
&nbsp;&nbsp; (requires Symbolic Math Toolbox)</b><br>
&nbsp;&nbsp; A coefficient matrix F for an m-variate polynomial
p of n terms satisfies:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1) (m+1) x n<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (2) each term of p
is represented by a column of F<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (3) F(m+1,k) is the
coefficient of the k-th term of p<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (4) F(j,k) for j=1:m
is the exponent for the j-th variable<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
in k-th term&nbsp;&nbsp; </span>
<p class="MsoNormal"> <span style="font-size: 10pt; font-family: &quot;Courier New&quot;;">&nbsp;&nbsp;
Syntax:&nbsp;&nbsp; &gt;&gt; F =
Polynomial2CoefficientMatrix(p,u)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt; F = Polynomial2CoefficientMatrix(p,[x,y,z])</span></p>
<p class="MsoNormal"> <span style="font-size: 10pt; font-family: &quot;Courier New&quot;;">&nbsp;&nbsp;
Input:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
p -- polynomial<br>
&nbsp;&nbsp;&nbsp; u or [x,y,z] -- vector of variables</span></p>
<p class="MsoNormal"> <span style="font-size: 10pt; font-family: &quot;Courier New&quot;;">&nbsp;&nbsp;
Oupput:&nbsp;&nbsp;&nbsp;&nbsp; F -- coefficient matrix</span></p>
<p class="MsoNormal"> <span style="font-size: 10pt; font-family: &quot;Courier New&quot;;">&nbsp;&nbsp;
Example:</span></p>
<p class="MsoNormal"> <span style="font-size: 10pt; font-family: &quot;Courier New&quot;;">&nbsp;
&gt;&gt; syms x y z&nbsp; % &gt;&gt; p = 3 +
x^3*y^2 - 4*y*z^5 + 8*x^2*y^4*z^4<br>
&nbsp; &gt;&gt; F = Polynomial2CoefficientMatrix(p,[x,y,z])</span></p>
<p class="MsoNormal"> <span style="font-size: 10pt; font-family: &quot;Courier New&quot;;">&nbsp;
F =</span></p>
<p class="MsoNormal"> <span style="font-size: 10pt; font-family: &quot;Courier New&quot;;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;
3&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp; 2<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;
2&nbsp;&nbsp;&nbsp;&nbsp;
1&nbsp;&nbsp;&nbsp;&nbsp; 4</span></p>
<p class="MsoNormal"> <span style="font-size: 10pt; font-family: &quot;Courier New&quot;;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;
5&nbsp;&nbsp;&nbsp;&nbsp; 4</span></p>
<p class="MsoNormal"> <span style="font-size: 10pt; font-family: &quot;Courier New&quot;;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
3&nbsp;&nbsp;&nbsp;&nbsp;
1&nbsp;&nbsp;&nbsp;
-4&nbsp;&nbsp;&nbsp;&nbsp; 8</span></p>
</li>
<li><b><font face="Agency FB" size="5"><a name="mvPolynDegree"> mvPolynDegree</a></font><font face="Courier New" size="5"><br>
</font><font face="Courier New">Computing the
total or tuple degree<br>
&nbsp;<br>
&nbsp;Syntax: &gt;&gt; d = mvPolynDegree(p,'total')<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt; d = mvPolynDegree(p,'tuple')<br>
<br>
</font></b><font face="Courier New">Example:<b><br>
<br>
</b><font color="#008000" size="2">&gt;&gt;
f<br>
<br>
f =<br>
&nbsp;&nbsp; 0&nbsp;&nbsp; 3&nbsp;&nbsp;
6&nbsp;&nbsp; 0&nbsp;&nbsp; 3&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 3&nbsp;&nbsp;
0&nbsp;&nbsp; 0<br>
&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 3&nbsp;&nbsp; 3&nbsp;&nbsp;
6&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp;
3&nbsp;&nbsp; 0<br>
&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 3&nbsp;&nbsp; 3&nbsp;&nbsp;
3&nbsp;&nbsp; 6<br>
&nbsp; -2&nbsp; -1&nbsp;&nbsp; 1&nbsp;
-1&nbsp;&nbsp; 2&nbsp;&nbsp; 1&nbsp;
-1&nbsp;&nbsp; 2&nbsp;&nbsp; 2&nbsp;&nbsp; 1<br>
<br>
&gt;&gt; d = mvPolynDegree(f,'total')<br>
<br>
d =<br>
&nbsp;&nbsp;&nbsp; 6<br>
<br>
&gt;&gt; d = mvPolynDegree(f,'tuple')<br>
<br>
d =<br>
&nbsp;&nbsp;&nbsp; 6&nbsp;&nbsp;
6&nbsp;&nbsp; 6<br>
</font><b><br>
&nbsp;</b></font></li>
<li><b><font face="Agency FB" size="5"><a name="mvPolynTimesMonom"> mvPolynTimesMonom</a></font><font face="Courier New" size="5">:<br>
</font><font face="Courier New">Compute a
multivariate polynomial p times a monomial t<br>
<br>
Syntax: &gt;&gt; f = mvPolynTimesMonom(p,t)<font size="5"><br>
</font><br>
</font></b><font face="Courier New">Example:<b><br>
<br>
</b><font size="2"><font color="#008000">&gt;&gt;
f<br>
<br>
f =<br>
&nbsp;&nbsp; 0&nbsp;&nbsp; 3&nbsp;&nbsp;
6&nbsp;&nbsp; 0&nbsp;&nbsp; 3&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 3&nbsp;&nbsp;
0&nbsp;&nbsp; 0<br>
&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 3&nbsp;&nbsp; 3&nbsp;&nbsp;
6&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp;
3&nbsp;&nbsp; 0<br>
&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 3&nbsp;&nbsp; 3&nbsp;&nbsp;
3&nbsp;&nbsp; 6<br>
&nbsp; -2&nbsp; -1&nbsp;&nbsp; 1&nbsp;
-1&nbsp;&nbsp; 2&nbsp;&nbsp; 1&nbsp;
-1&nbsp;&nbsp; 2&nbsp;&nbsp; 2&nbsp;&nbsp; 1<br>
<br>
&gt;&gt; t = [2,3,1,5]'<br>
<br>
t =<br>
&nbsp;&nbsp; 2<br>
&nbsp;&nbsp; 3<br>
&nbsp;&nbsp; 1<br>
&nbsp;&nbsp; 5<br>
<br>
&gt;&gt; mvPolynTimesMonom(f,t)<br>
<br>
ans =<br>
&nbsp;&nbsp; 2&nbsp;&nbsp; 5&nbsp;&nbsp;
8&nbsp;&nbsp; 2&nbsp;&nbsp; 5&nbsp;&nbsp;
2&nbsp;&nbsp; 2&nbsp;&nbsp; 5&nbsp;&nbsp;
2&nbsp;&nbsp; 2<br>
&nbsp;&nbsp; 3&nbsp;&nbsp; 3&nbsp;&nbsp;
3&nbsp;&nbsp; 6&nbsp;&nbsp; 6&nbsp;&nbsp;
9&nbsp;&nbsp; 3&nbsp;&nbsp; 3&nbsp;&nbsp;
6&nbsp;&nbsp; 3<br>
&nbsp;&nbsp; 1&nbsp;&nbsp; 1&nbsp;&nbsp;
1&nbsp;&nbsp; 1&nbsp;&nbsp; 1&nbsp;&nbsp;
1&nbsp;&nbsp; 4&nbsp;&nbsp; 4&nbsp;&nbsp;
4&nbsp;&nbsp; 7<br>
&nbsp;-10&nbsp; -5&nbsp;&nbsp; 5&nbsp; -5&nbsp;
10&nbsp;&nbsp; 5&nbsp; -5&nbsp; 10&nbsp;
10&nbsp;&nbsp; 5</font><br>
&nbsp;</font></font></li>
<li><b><font face="Agency FB" size="5"><a name="mvPolynAdd">mvPolynAdd</a></font><font face="Courier New">:<br>
Compute the addition f+g of two multivariate polynomials f and g, <br>
or the linear combination s*f + t*g if scalars s and t are also given<br>
<br>
Syntax: &gt;&gt; d = mvPolynAdd(f,g)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt; d = mvPolynAdd(f,g,s,t)<br>
<br>
Input: f, g -- multivariate polynomials in coeff. matrices<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s, t --
(optional) complex numbers<br>
<br>
Output: multivariate polynomial f+g, or s*f + t*g<br>
<br>
</font></b><font face="Courier New">Example:
<br>
<b><br>
</b><font color="#008000" size="2">&gt;&gt;
f<br>
<br>
f =<br>
&nbsp;&nbsp; 0&nbsp;&nbsp; 2&nbsp;
4&nbsp;&nbsp; 0&nbsp; 2&nbsp; 0<br>
&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;
0&nbsp;&nbsp; 2&nbsp; 2&nbsp; 4<br>
&nbsp; -2&nbsp; -1&nbsp; 1&nbsp; -1&nbsp;
2&nbsp; 1<br>
<br>
&gt;&gt; p <br>
<br>
p =<br>
&nbsp;&nbsp; 3&nbsp;&nbsp; 5&nbsp;&nbsp;
7&nbsp;&nbsp; 3&nbsp;&nbsp; 5&nbsp;&nbsp; 3<br>
&nbsp;&nbsp; 1&nbsp;&nbsp; 1&nbsp;&nbsp;
1&nbsp;&nbsp; 3&nbsp;&nbsp; 3&nbsp;&nbsp; 5<br>
&nbsp;&nbsp; 8&nbsp; 12&nbsp;&nbsp; 4&nbsp;
12&nbsp;&nbsp; 8&nbsp;&nbsp; 4<br>
<br>
&gt;&gt; r = mvPolynAdd(f,p,1,-1) % compute r=f-p<br>
<br>
r =<br>
&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;
2&nbsp;&nbsp; 4&nbsp;&nbsp; 3&nbsp;&nbsp;
5&nbsp;&nbsp; 7&nbsp;&nbsp; 0&nbsp;&nbsp;
2&nbsp;&nbsp; 3&nbsp;&nbsp; 5&nbsp;&nbsp;
0&nbsp;&nbsp; 3<br>
&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 1&nbsp;&nbsp;
1&nbsp;&nbsp; 1&nbsp;&nbsp; 2&nbsp;&nbsp;
2&nbsp;&nbsp; 3&nbsp;&nbsp; 3&nbsp;&nbsp;
4&nbsp;&nbsp; 5<br>
&nbsp;&nbsp; -2&nbsp; -1&nbsp;&nbsp; 1&nbsp; -8
-12&nbsp; -4&nbsp; -1&nbsp;&nbsp; 2 -12&nbsp;
-8&nbsp;&nbsp; 1&nbsp; -4</font><b><br>
&nbsp;</b></font></li>
<li><b><font face="Agency FB" size="5"><a name="mvPolynMultiply"> mvPolynMultiply</a></font><font face="Courier New">:<br>
Compute the product f*g of two multivariate polynomials f and g<br>
&nbsp;<br>
Syntax: &gt;&gt; h = mvPolynMultiply(f,g)<br>
Input: f, g -- multivariate polynomials in coeff. matrices<br>
<br>
Output: multivariate polynomial f*g<br>
<br>
</font></b><font face="Courier New">Example:<br>
<br>
<font size="2"><font color="#008000">&gt;&gt;
f <br>
<br>
f =<br>
&nbsp;&nbsp; 0&nbsp;&nbsp; 2&nbsp;&nbsp;
4&nbsp;&nbsp; 0<br>
&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 2<br>
&nbsp; -4&nbsp; -2&nbsp;&nbsp; 2&nbsp; -2<br>
<br>
&gt;&gt; g <br>
<br>
g =<br>
&nbsp;&nbsp; 3&nbsp;&nbsp; 5&nbsp;&nbsp; 7<br>
&nbsp;&nbsp; 1&nbsp;&nbsp; 1&nbsp;&nbsp; 1<br>
&nbsp;&nbsp; 8&nbsp; 12&nbsp;&nbsp; 4<br>
<br>
&gt;&gt; mvPolynMultiply(f,g)<br>
<br>
ans =<br>
&nbsp;&nbsp;&nbsp;&nbsp;
3&nbsp;&nbsp;&nbsp; 5&nbsp;&nbsp;&nbsp;
7&nbsp;&nbsp;&nbsp; 9&nbsp;&nbsp;
11&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;
5&nbsp;&nbsp;&nbsp; 7<br>
&nbsp;&nbsp;&nbsp;&nbsp;
1&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;
1&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;
1&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;
3&nbsp;&nbsp;&nbsp; 3<br>
&nbsp;&nbsp; -32&nbsp; -64&nbsp;
-24&nbsp;&nbsp; 16&nbsp;&nbsp;&nbsp; 8&nbsp;
-16&nbsp; -24&nbsp;&nbsp; -8</font><br>
&nbsp;</font></font></li>
<li><b><font face="Agency FB" size="5"><a name="mvPolynPower">mvPolynPower</a></font></b><br>
<font face="Courier New">Compute the power f^k of the
multivariate polynomials f <br>
<br>
Syntax:&nbsp;&nbsp; &gt;&gt; h = mvPolynPower(f,k)<br>
<br>
Input:&nbsp; f -- multivariate polynomials in coeff. matrices<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
k -- integer exponent of the power<br>
<br>
Output: multivariate polynomial f^k<br>
<br>
<b>Example</b>:<br>
<br>
<font color="#008000" size="2">&gt;&gt;
f<br>
<br>
f =<br>
&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;
2&nbsp;&nbsp; 4&nbsp;&nbsp; 0<br>
&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 2<br>
&nbsp;&nbsp; -4&nbsp; -2&nbsp;&nbsp; 2&nbsp; -2<br>
<br>
&gt;&gt; mvPolynPower(f,3)<br>
<br>
ans =<br>
&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;
2&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;
6&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp;
10&nbsp;&nbsp; 12&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;
4&nbsp;&nbsp;&nbsp; 6&nbsp;&nbsp;&nbsp;
8&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;
2&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp; 0<br>
&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;
2&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;
2&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;
2&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;
4&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp; 6<br>
&nbsp; -64&nbsp; -96&nbsp;&nbsp; 48&nbsp;&nbsp;
88&nbsp; -24&nbsp; -24&nbsp;&nbsp;&nbsp;
8&nbsp; -96&nbsp; -96&nbsp;&nbsp;
72&nbsp;&nbsp; 48&nbsp; -24&nbsp; -48&nbsp;
-24&nbsp;&nbsp; 24&nbsp;&nbsp; -8<br>
</font><br>
<br>
&nbsp;</font></li>
<li><b><font face="Agency FB" size="5"><a name="mvPolynEvaluate"> mvPolynEvaluate</a></font></b><font face="Courier New">:<br>
&nbsp;Evaluate multivariate polynomial f at x<br>
<br>
&nbsp;&nbsp;&nbsp; Syntax:&nbsp;&nbsp;
&gt;&gt; y = mvPolynEvaluate(f,x)<br>
<br>
&nbsp;&nbsp;&nbsp; Input:&nbsp;&nbsp; f --
multivariate polynomial (as a coeff. matrix)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
x -- vector value for the variables<br>
<br>
&nbsp;&nbsp;&nbsp; utput: the value of f(x)<br>
<br>
Example:<br>
<br>
<font color="#008000" size="2">&gt;&gt;
f<br>
<br>
f =<br>
&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;
2&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp; 0<br>
&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp; 2<br>
&nbsp; -4&nbsp;&nbsp; -2&nbsp;&nbsp;&nbsp;
2&nbsp;&nbsp; -2<br>
<br>
&gt;&gt; mvPolynEvaluate(f,[1;1])<br>
<br>
ans =<br>
<br>
&nbsp;&nbsp; -6</font></font><br>
<br>
&nbsp;</li>
<li><b><font face="Agency FB" size="5"><a name="mvPolynDerivative"> mvPolynDerivative</a></font></b><br>
<font face="Courier New">Compute the partial
derivative of the multivariate polynomial p<br>
with respect to the j-th variable<br>
<br>
Syntax: &gt;&gt; q = mvPolynDerivative(p,j)<br>
<br>
Input: <br>
p -- polynomial in coefficient matrix<br>
j -- index of the variable w.r.t. which the derivative is to be taken<br>
<br>
Output: multivariate polynomial as the partial derivative<br>
<br>
<b>Example:</b>&nbsp; <br>
<br>
<font color="#008000" size="2">&gt;&gt;
p = [2 1 0 0; 0 1 2 0; 1 1 -1 1]<br>
<br>
p =<br>
&nbsp;&nbsp; 2&nbsp;&nbsp; 1&nbsp;&nbsp;
0&nbsp;&nbsp; 0<br>
&nbsp;&nbsp; 0&nbsp;&nbsp; 1&nbsp;&nbsp;
2&nbsp;&nbsp; 0<br>
&nbsp;&nbsp; 1&nbsp;&nbsp; 1&nbsp;
-1&nbsp;&nbsp; 1<br>
<br>
&gt;&gt; mvPolynDerivative(p,1)<br>
<br>
ans =<br>
&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp; 0<br>
&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp; 1<br>
&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp; 1<br>
<br>
&gt;&gt; mvPolynDerivative(p,2)<br>
<br>
ans =<br>
&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp; 0<br>
&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp; 1<br>
&nbsp;&nbsp;&nbsp; 1&nbsp; -2</font></font><font color="#008000" size="2"><br>
<br>
&nbsp;</font></li>
<li><b><font face="Agency FB" size="5"><a name="mvPolynClear">mvPolynClear</a></font></b><br>
<font face="Courier New">Clear tiny/zero coefficients
of a multivariate polynomial f<br>
<br>
Syntax: <br>
&nbsp;&nbsp;&nbsp;&nbsp; &gt;&gt; g =
mvPolynClear(f)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
% clear zero coefficients of f<br>
&nbsp;&nbsp;&nbsp;&nbsp; &gt;&gt; g =
mvPolynClear(f,epsilon) % clear coefficients whose magnitudes<br>
are less than or equal to epsilon<br>
<br>
Input:&nbsp;&nbsp;&nbsp; f -- multivariate polynomial (as a
coeff. matrix)<br>
&nbsp;&nbsp;&nbsp; epsilon -- magnitude threshold of
coefficients to be cleared<br>
<br>
Output: multivariate polynomial in coefficient matrix<br>
<br>
<b>Example:</b> <br>
<br>
<font color="#008000" size="2">&gt;&gt;
h<br>
<br>
h =<br>
&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;
5&nbsp;&nbsp;&nbsp; 7&nbsp;&nbsp;&nbsp;
9&nbsp;&nbsp; 11&nbsp;&nbsp;&nbsp;
3&nbsp;&nbsp;&nbsp; 5&nbsp;&nbsp;&nbsp; 7<br>
&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;
1&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;
1&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;
3&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp; 3<br>
&nbsp; -32&nbsp;&nbsp;&nbsp; 0&nbsp;
-24&nbsp;&nbsp; 16&nbsp;&nbsp;&nbsp; 0&nbsp;
-16&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp; -8<br>
<br>
&gt;&gt; mvPolynClear(h)<br>
<br>
ans =<br>
&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;
7&nbsp;&nbsp;&nbsp; 9&nbsp;&nbsp;&nbsp;
3&nbsp;&nbsp;&nbsp; 7<br>
&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;
1&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;
3&nbsp;&nbsp;&nbsp; 3<br>
&nbsp; -32&nbsp; -24&nbsp;&nbsp; 16&nbsp;
-16&nbsp;&nbsp; -8<br>
</font></font><font color="#008000" size="2"><br>
</font><font face="Courier New"><font color="#008000" size="2">&gt;&gt; g<br>
<br>
g =<br>
&nbsp; 3.0000e+000&nbsp; 5.0000e+000&nbsp;
7.0000e+000&nbsp; 3.0000e+000&nbsp; 5.0000e+000&nbsp;
3.0000e+000<br>
&nbsp; 1.0000e+000&nbsp; 1.0000e+000&nbsp;
1.0000e+000&nbsp; 3.0000e+000&nbsp; 3.0000e+000&nbsp;
5.0000e+000<br>
&nbsp; 8.0000e+000&nbsp; 9.5013e-013&nbsp;
4.0000e+000&nbsp; 1.2000e+001&nbsp; 8.0000e+000&nbsp;
2.3114e-013<br>
<br>
&gt;&gt; mvPolynClear(g,1e-10)<br>
<br>
ans =<br>
&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;
7&nbsp;&nbsp; 3&nbsp;&nbsp; 5<br>
&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;
1&nbsp;&nbsp; 3&nbsp;&nbsp; 3<br>
&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp; 4&nbsp;
12&nbsp;&nbsp; 8</font><br>
</font><br>
<br>
&nbsp;</li>
<li><b><font face="Agency FB" size="5"><a name="HouseholderVector"> HouseholderVector</a></font></b><font face="courier new">:<br>
<b>computing the Householder vector u such that<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
H = I - 2*u*u' <br>
makes Hv = [*;0;...;0] <br>
<br>
syntax &gt;&gt; u = HouseholderVector(v)</b><br>
<br>
Example:&nbsp; <br>
<br>
<font size="2"><font color="#008000">&gt;&gt;
v = rand(5,1)<br>
<br>
v =<br>
&nbsp;&nbsp; 0.8381<br>
&nbsp;&nbsp; 0.0196<br>
&nbsp;&nbsp; 0.6813<br>
&nbsp;&nbsp; 0.3795<br>
&nbsp;&nbsp; 0.8318<br>
<br>
&gt;&gt; u = HouseholderVector(v)<br>
<br>
u =<br>
&nbsp;&nbsp; 0.8922<br>
&nbsp;&nbsp; 0.0078<br>
&nbsp;&nbsp; 0.2698<br>
&nbsp;&nbsp; 0.1503<br>
&nbsp;&nbsp; 0.3294<br>
<br>
&gt;&gt; (eye(5)-2*u*u')*v<br>
<br>
ans =<br>
&nbsp; -1.4152<br>
&nbsp; -0.0000<br>
&nbsp; -0.0000<br>
&nbsp; -0.0000<br>
&nbsp; -0.0000</font><br>
&nbsp;</font></font></li>
<li><b><font size="5"> <a name="HouseholderTransform:"><font face="Agency FB">HouseholderTransform</font><font face="courier new">:</font></a></font></b><font face="courier new"> <br>
<b>computing the Householder transformation w = H*v with <br>
&nbsp;&nbsp;&nbsp;&nbsp; H = I - 2*u*u' <br>
<br>
syntax &gt;&gt; w = HouseholderTransform(u,v)<br>
<br>
</b>Example:<br>
<br>
<font color="#008000" size="2">&gt;&gt;
v<br>
<br>
v =<br>
&nbsp;&nbsp; 0.8381<br>
&nbsp;&nbsp; 0.0196<br>
&nbsp;&nbsp; 0.6813<br>
&nbsp;&nbsp; 0.3795<br>
&nbsp;&nbsp; 0.8318<br>
<br>
&gt;&gt; u = HouseholderVector(v)<br>
<br>
u =<br>
&nbsp;&nbsp; 0.8922<br>
&nbsp;&nbsp; 0.0078<br>
&nbsp;&nbsp; 0.2698<br>
&nbsp;&nbsp; 0.1503<br>
&nbsp;&nbsp; 0.3294<br>
<br>
&gt;&gt; w = HouseholderTransform(u,v)<br>
<br>
w =<br>
&nbsp; -1.4152<br>
&nbsp; -0.0000<br>
&nbsp; -0.0000<br>
&nbsp; -0.0000<br>
&nbsp; -0.0000</font><br>
<br>
&nbsp;</font></li>
<li><b><font face="Agency FB" size="5">
<a name="HouseholderTransformRight">HouseholderTransformRight</a></font></b><font face="courier new">:<br>
computing the Householder transformation from right side w =
v*H&nbsp; with <br>
&nbsp;&nbsp;&nbsp; H = I - 2*u*u' <br>
<br>
syntax &gt;&gt; w = HouseholderTransformRight(u,v)<br>
<br>
Example:<br>
<br>
<font color="#008000" size="2">&gt;&gt;
a = v'<br>
<br>
a =<br>
&nbsp;&nbsp; 0.8381&nbsp;&nbsp;
0.0196&nbsp;&nbsp; 0.6813&nbsp;&nbsp;
0.3795&nbsp;&nbsp; 0.8318<br>
<br>
&gt;&gt; u = HouseholderVector(v);<br>
&gt;&gt; w = HouseholderTransformRight(u,a)<br>
<br>
w =<br>
&nbsp; -1.4152&nbsp; -0.0000&nbsp; -0.0000&nbsp;
-0.0000&nbsp; -0.0000</font><br>
<br>
&nbsp;</font></li>
<li><b><font face="Agency FB" size="5"><a name="GivensMatrix"> GivensMatrix</a></font></b><font face="courier new">:<br>
Generating a Givens' (2x2) matrix T such that<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
T*v = [d; 0] <br>
<br>
Input: v -- a vector of dimension 2 <br>
<br>
Output: T -- Givens' matrix <br>
d -- the 2-norm of v <br>
<br>
syntax &gt;&gt; [T,d] = GivensMatrix(v)<br>
<br>
<u>Example:</u><br>
<br>
<font color="#008000"> <font size="2">&gt;&gt;
v<br>
<br>
v =<br>
&nbsp;&nbsp; 0.7907<br>
&nbsp; -1.5935<br>
<br>
&gt;&gt; [T,d] = GivensMatrix(v)<br>
<br>
T =<br>
&nbsp;&nbsp; 0.4445&nbsp; -0.8958<br>
&nbsp;&nbsp; 0.8958&nbsp;&nbsp; 0.4445<br>
<br>
<br>
d =<br>
&nbsp;&nbsp; 1.7789<br>
<br>
&gt;&gt; T*v<br>
<br>
ans =<br>
&nbsp;&nbsp; 1.7789<br>
&nbsp;&nbsp; 0.0000</font><br>
</font> <br>
&nbsp;</font></li>
<li><b><font size="5"><a name="IntegerInverse:"> <font face="Agency FB">IntegerInverse</font><font face="courier new">:</font></a></font></b><font face="courier new"><br>
<b>generate a pair of nxn integer matrices that are inverse
to each other <br>
<br>
syntax &gt;&gt; [X,Y] = IntegerInverse(n)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt; [X,Y] = IntegerInverse(n,m) % entries in interval
[-m,m]</b><br>
<br>
This module is mainly used to generate test cases<br>
<br>
Example: <br>
<br>
<font color="#008000" size="2">&gt;&gt;
[X,Y] = IntegerInverse(5)<br>
<br>
</font></font><font color="#008000" face="Courier New"><font size="2">X =<br>
&nbsp;
&nbsp;1&nbsp;&nbsp; 0&nbsp; -1&nbsp;&nbsp;
0&nbsp;&nbsp; 0<br>
&nbsp;
&nbsp;0&nbsp;&nbsp; 1&nbsp;&nbsp; 0&nbsp;
-1&nbsp; -1<br>
&nbsp; -1&nbsp;&nbsp; 0&nbsp;&nbsp;
2&nbsp;&nbsp; 0&nbsp;&nbsp; 0<br>
&nbsp;
&nbsp;0&nbsp; -1&nbsp;&nbsp; 0&nbsp;&nbsp;
2&nbsp;&nbsp; 1<br>
&nbsp;
&nbsp;0&nbsp; -1&nbsp;&nbsp; 0&nbsp;&nbsp;
1&nbsp;&nbsp; 2<br>
<br>
<br>
Y =<br>
&nbsp;
&nbsp;2&nbsp;&nbsp; 0&nbsp;&nbsp;
1&nbsp;&nbsp; 0&nbsp;&nbsp; 0<br>
&nbsp;
&nbsp;0&nbsp;&nbsp; 3&nbsp;&nbsp;
0&nbsp;&nbsp; 1&nbsp;&nbsp; 1<br>
&nbsp;
&nbsp;1&nbsp;&nbsp; 0&nbsp;&nbsp;
1&nbsp;&nbsp; 0&nbsp;&nbsp; 0<br>
&nbsp;
&nbsp;0&nbsp;&nbsp; 1&nbsp;&nbsp;
0&nbsp;&nbsp; 1&nbsp;&nbsp; 0<br>
&nbsp;
&nbsp;0&nbsp;&nbsp; 1&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 1<br>
<br>
&gt;&gt; X*Y<br>
<br>
ans =<br>
&nbsp;
&nbsp;1&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 0<br>
&nbsp;
&nbsp;0&nbsp;&nbsp; 1&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 0<br>
&nbsp;
&nbsp;0&nbsp;&nbsp; 0&nbsp;&nbsp;
1&nbsp;&nbsp; 0&nbsp;&nbsp; 0<br>
&nbsp;
&nbsp;0&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 1&nbsp;&nbsp; 0<br>
&nbsp;
&nbsp;0&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 1</font><br>
&nbsp;</font></li>
<li><b><font face="Agency FB" size="5"><a name="MatrixWithGivenJordanForm"> MatrixWithGivenJordanForm</a></font></b><font face="Courier New"><br>
Construct a matrix with given Jordan Canonical Form<br>
<br>
Syntax: There are several choices for either LHS or RHS<br>
&nbsp;&nbsp; &gt;&gt;
LHS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
=&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
RHS<br>
------------------- | --------------------------------------<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|&nbsp;&nbsp; MatrixWithGivenJordanForm(s,j)<br>
&nbsp;&nbsp;&nbsp;&nbsp;
[A,X]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|&nbsp;&nbsp; MatrixWithGivenJordanForm(s,j,k)<br>
&nbsp;&nbsp;&nbsp;&nbsp;
[A,X,Y]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
| <br>
<br>
Input:<br>
&nbsp;&nbsp;&nbsp;&nbsp; s -- eigenvalues in each
Jordan block<br>
&nbsp;&nbsp;&nbsp;&nbsp; j -- size of each Jordan block<br>
&nbsp;&nbsp;&nbsp;&nbsp; k -- (optional) number of
(simple) eigenvalues of a kxk random matrix<br>
<br>
Output: <br>
&nbsp;&nbsp;&nbsp;&nbsp; A -- a matrix whose
eigenvalues and Jordan structure are defined by<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
input s, j and k<br>
&nbsp;&nbsp; X,Y -- matrices such that Y*A*X is the Jordan
Canonical Form of A<br>
<br>
<b>Example:&nbsp; </b>To generate a matrix with <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
eigenvalues | Jordan block sizes<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|&nbsp;&nbsp;&nbsp;&nbsp; 4, 3, 2<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|&nbsp;&nbsp;&nbsp;&nbsp; 2, 2<br>
<br>
<font color="#008000" size="2">&gt;&gt;
[A,X,Y] = MatrixWithGivenJordanForm([2 2 2 3 3],[3 2 1 2 2])<br>
<br>
A =<br>
&nbsp;&nbsp; -2&nbsp;&nbsp; 8&nbsp; -4&nbsp;
-3&nbsp;&nbsp; 1&nbsp; -1&nbsp; -1&nbsp;
-1&nbsp;&nbsp; 1&nbsp;&nbsp; 1<br>
&nbsp;&nbsp;&nbsp; 4&nbsp; -4&nbsp;&nbsp;
5&nbsp;&nbsp; 1&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 1&nbsp;&nbsp; 2&nbsp;&nbsp;
1&nbsp; -2<br>
&nbsp;&nbsp;&nbsp; 8 -15&nbsp; 10&nbsp;&nbsp;
6&nbsp; -3&nbsp;&nbsp; 2&nbsp;&nbsp;
2&nbsp;&nbsp; 2&nbsp; -2&nbsp; -2<br>
&nbsp;&nbsp; -1&nbsp;&nbsp; 5&nbsp; -1&nbsp;
-1&nbsp;&nbsp; 4&nbsp; -2&nbsp; -1&nbsp;
-1&nbsp;&nbsp; 2&nbsp;&nbsp; 0<br>
&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp;
2&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 0<br>
&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;
2&nbsp;&nbsp; 1&nbsp; -2&nbsp;&nbsp;
1&nbsp;&nbsp; 1&nbsp;&nbsp; 0&nbsp;&nbsp;
1&nbsp;&nbsp; 2&nbsp; -1<br>
&nbsp;&nbsp;&nbsp; 2&nbsp; -6&nbsp;&nbsp;
4&nbsp;&nbsp; 1&nbsp; -2&nbsp;&nbsp;
1&nbsp;&nbsp; 4&nbsp;&nbsp; 4&nbsp;&nbsp;
1&nbsp; -2<br>
&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp;
3&nbsp;&nbsp; 0&nbsp;&nbsp; 0<br>
&nbsp; -10&nbsp; 21 -11&nbsp; -7&nbsp;&nbsp;
5&nbsp; -3&nbsp; -3&nbsp; -5&nbsp;&nbsp;
4&nbsp;&nbsp; 4<br>
&nbsp;&nbsp; -5&nbsp;&nbsp; 8&nbsp;
-8&nbsp;&nbsp; 2&nbsp; -2&nbsp;&nbsp; 1&nbsp;
-1&nbsp; -4&nbsp; -4&nbsp;&nbsp; 7<br>
<br>
<br>
X =<br>
&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp; 0&nbsp;
-1&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp;
1&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp;
1&nbsp;&nbsp; 0<br>
&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;
1&nbsp;&nbsp; 1&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 1&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp; -1&nbsp; -1<br>
&nbsp;&nbsp; -1&nbsp;&nbsp; 1&nbsp;&nbsp;
3&nbsp; -1&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;
-3&nbsp;&nbsp; 0<br>
&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;
-1&nbsp;&nbsp; 2&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp; -1&nbsp;&nbsp; 0&nbsp;&nbsp; 2&nbsp; -1<br>
&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp;
1&nbsp;&nbsp; 1&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 0<br>
&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;
1&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp;
1&nbsp;&nbsp; 4&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp; -1<br>
&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp; -1&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 2&nbsp;&nbsp;
0&nbsp; -1&nbsp;&nbsp; 0<br>
&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp;
1&nbsp;&nbsp; 0&nbsp;&nbsp; 1<br>
&nbsp;&nbsp;&nbsp; 1&nbsp; -1&nbsp;
-3&nbsp;&nbsp; 2&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp; -1&nbsp;&nbsp; 0&nbsp;&nbsp;
5&nbsp;&nbsp; 1<br>
&nbsp;&nbsp;&nbsp; 0&nbsp; -1&nbsp;&nbsp;
0&nbsp; -1&nbsp;&nbsp; 0&nbsp; -1&nbsp;&nbsp;
0&nbsp;&nbsp; 1&nbsp;&nbsp; 1&nbsp;&nbsp; 5<br>
<br>
<br>
Y =<br>
&nbsp;&nbsp;&nbsp; 6&nbsp; -3&nbsp;&nbsp;
3&nbsp;&nbsp; 3&nbsp;&nbsp; 1&nbsp;
-1&nbsp;&nbsp; 1&nbsp;&nbsp; 0&nbsp;
-1&nbsp;&nbsp; 0<br>
&nbsp;&nbsp; -3&nbsp;&nbsp; 7&nbsp; -4&nbsp;
-2&nbsp;&nbsp; 1&nbsp; -1&nbsp; -1&nbsp;
-1&nbsp;&nbsp; 0&nbsp;&nbsp; 1<br>
&nbsp;&nbsp;&nbsp; 3&nbsp; -4&nbsp;&nbsp;
4&nbsp;&nbsp; 1&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 1&nbsp;&nbsp; 1&nbsp;&nbsp;
1&nbsp; -1<br>
&nbsp;&nbsp;&nbsp; 3&nbsp; -2&nbsp;&nbsp;
1&nbsp;&nbsp; 4&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 1&nbsp; -1&nbsp; -2&nbsp;&nbsp; 1<br>
&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;
1&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp;
2&nbsp; -1&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 0<br>
&nbsp;&nbsp; -1&nbsp; -1&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp; -1&nbsp;&nbsp;
1&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 0<br>
&nbsp;&nbsp;&nbsp; 1&nbsp; -1&nbsp;&nbsp;
1&nbsp;&nbsp; 1&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 1&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 0<br>
&nbsp;&nbsp;&nbsp; 0&nbsp; -1&nbsp;&nbsp;
1&nbsp; -1&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 2&nbsp;&nbsp;
1&nbsp; -1<br>
&nbsp;&nbsp; -1&nbsp;&nbsp; 0&nbsp;&nbsp;
1&nbsp; -2&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 1&nbsp;&nbsp;
2&nbsp; -1<br>
&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp; 1&nbsp;
-1&nbsp;&nbsp; 1&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp; -1&nbsp; -1&nbsp;&nbsp; 1</font><br>
<br>
The results can be verified:<br>
<br>
<font color="#008000" size="2">&gt;&gt;
Y*A*X<br>
<br>
ans =<br>
<br>
&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;
1&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 0<br>
&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;
2&nbsp;&nbsp; 1&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 0<br>
&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 2&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 0<br>
&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 2&nbsp;&nbsp;
1&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 0<br>
&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp;
2&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 0<br>
&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 2&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 0<br>
&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 3&nbsp;&nbsp;
1&nbsp;&nbsp; 0&nbsp;&nbsp; 0<br>
&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp;
3&nbsp;&nbsp; 0&nbsp;&nbsp; 0<br>
&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 3&nbsp;&nbsp; 1<br>
&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp;
0&nbsp;&nbsp; 0&nbsp;&nbsp; 3</font><br>
&nbsp;</font></li>
<li><b><font face="Agency FB" size="5"><a name="ScaledLeastSquares"> ScaledLeastSquares</a></font></b><font face="Courier New">:<br>
Scaled least squares solver for A*x = b<br>
<br>
Input: A -- matrix <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v --
right-side vector <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; w --
(optional) weight vector <br>
<br>
Output: (return) -- the least squares solution <br>
<br>
syntax &gt;&gt; x = ScaledLeastSquares(A,b)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt; x = ScaledLeastSquares(A,b,w)<br>
<br>
</font></li>
<li><b><font face="Agency FB" size="5"><a name="GetVariables"></a>GetVariables </font></b><span style="font-family: Courier New;">(alias </span><b><font face="Agency FB" size="5">pvar</font></b><span style="font-family: Courier New;">)</span><br>
&nbsp; <span style="font-family: Courier New;">Extract
variable names from a polynomial string</span><br style="font-family: Courier New;">
<span style="font-family: Courier New;">&nbsp;</span><br style="font-family: Courier New;">
<span style="font-family: Courier New;">&nbsp;
Syntax:&nbsp; &gt;&gt; z = GetVariables(f)</span><br style="font-family: Courier New;">
<span style="font-family: Courier New;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
or:&nbsp; &gt;&gt; z = pvar(f)</span><br style="font-family: Courier New;">
<span style="font-family: Courier New;">&nbsp;</span><br style="font-family: Courier New;">
<span style="font-family: Courier New;">&nbsp;&nbsp;
Input:&nbsp;&nbsp; f --- (string) polynomial</span><br style="font-family: Courier New;">
<span style="font-family: Courier New;">&nbsp;
Output:&nbsp;&nbsp; z --- (cell)&nbsp;&nbsp; variable
names of f</span><br style="font-family: Courier New;">
<span style="font-family: Courier New;">&nbsp; </span><br style="font-family: Courier New;">
<span style="font-family: Courier New;">&nbsp;
Example:&nbsp; &gt;&gt; g = '-2*x + 9*x*y^2 - 9*x^2*y^2 +
8*x^3*y^2';</span><br style="font-family: Courier New;">
<span style="font-family: Courier New;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt; z = GetVariables(g)</span><br style="font-family: Courier New;">
<span style="font-family: Courier New;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
z = </span><br style="font-family: Courier New;">
<span style="font-family: Courier New;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
'x'&nbsp;&nbsp;&nbsp; 'y'</span></li>
<li><b><font face="Agency FB" size="5"><a name="pcoef"></a>PolynomialCoefficient&nbsp;</font></b><span style="font-family: Courier New;">(alias </span><b><font face="Agency FB" size="5">pcoef</font></b><span style="font-family: Courier New;">)</span><br>
<font face="Courier New"> &nbsp; Extract the
coefficient of a monomial t in the polynomial p<br>
&nbsp;<br>
&nbsp; Syntax:&nbsp;&nbsp; (pcoef is the shortened alias
for PolynomialCoefficient)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt; c = PolynomialCoefficient(p,t)<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp; Input:&nbsp;&nbsp;&nbsp; p
--- (string) polynomial<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
t --- (string) monomial<br>
&nbsp;<br>
&nbsp;&nbsp; Output:&nbsp;&nbsp;&nbsp; c ---
(numeric or string) the coefficient of t in p<br>
&nbsp;<br>
&nbsp; Example:&nbsp;&nbsp; &gt;&gt; p = '-2*x +
9*x*y^2 - 9*x^2*y^2 + 8*x^3*y^2';<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt; c = PolynomialCoefficient(p,'y^2')<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
c =<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
9*x - 9*x^2 + 8*x^3<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt; d = PolynomialCoefficient(p,'x*y^2')<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
d =<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-9</font></li>
<li><b><font face="Agency FB" size="5"><a name="pder"></a>PolynomialDerivative </font></b><span style="font-family: Courier New;">(alias </span><b><font face="Agency FB" size="5">pder</font></b><span style="font-family: Courier New;">)</span><br>
<font face="Courier New">&nbsp;&nbsp;
Calculate a (partial) derivative of a polynomial f<br>
&nbsp;<br>
&nbsp; Syntax:&nbsp; (pder is the shortened alias for
PolynomialDerivative)<br>
&nbsp;&nbsp;&nbsp; &gt;&gt; p =
PolynomialDerivative(f)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
% if f is univariate<br>
&nbsp;&nbsp;&nbsp; &gt;&gt; p =
PolynomialDerivative(f,'x',k)&nbsp; % k-th derivative of f(x)<br>
&nbsp;&nbsp;&nbsp; &gt;&gt; p =
PolynomialDerivative(f,z)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
% partial derivative of f <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
w.r.t. all variables in z<br>
&nbsp;&nbsp;&nbsp; &gt;&gt; p =
PolynomialDerivative(f,z,k)<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;&nbsp; Input:&nbsp;&nbsp; f ---
(string)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
polynomial<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
z --- (string or cell)&nbsp;&nbsp;&nbsp; variable name(s)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
k --- (integer or vector, optional) derivative orders, <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
assumed to be ones if not provided<br>
&nbsp;<br>
&nbsp; Output:&nbsp;&nbsp; p --- (string)&nbsp;
(partial) derivative of f<br>
&nbsp;<br>
&nbsp; Example:&nbsp; &gt;&gt; f = '3*x^5+2*x+8';<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt; Diff(f)<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ans =<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
2 + 15*x^4<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt; g = '-2*x + 9*x*y^2 - 9*x^2*y^2 + 8*x^3*y^2';<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt; PolynomialPolynomialDerivative(g,{'x','y'},[2,1])<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ans =<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-36*y + 96*x*y<br>
<br>
</font></li>
<li><b><font face="Agency FB" size="5"><a name="peval"></a>PolynomialEvaluate </font></b><span style="font-family: Courier New;">(alias </span><b><font face="Agency FB" size="5">peval</font></b><span style="font-family: Courier New;">)<br>
&nbsp; Evaluate a polynomial at given values of (some or all)
values. The result<br>
&nbsp; can be a number or a polynomial of remaining variables<br>
&nbsp;<br>
&nbsp; Syntax: (peval is the shortened alias for PolynomilaEvaluate)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt; s = PolynomialEvaluate(f, var, z)<br>
&nbsp;<br>
&nbsp; Input:&nbsp;&nbsp; f --- (string) polynomial<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
var --- (cell)&nbsp;&nbsp; variable names<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
z --- (vector) values of the variables in var<br>
&nbsp;<br>
&nbsp; Output:&nbsp; s --- (numeric or string) value of the
polynomial<br>
&nbsp;<br>
&nbsp; Example: &gt;&gt; g = '-2*x + 9*x*y^2 - 9*z^2*y^2 +
8*x^3*y^2*z^4';<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt; PolynomialEvaluate(g,{'x','z'},[2,1])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ans =<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-4 + 73*y^2<br>
<br>
</span></li>
<li><b><font face="Agency FB" size="5"><a name="pfac"></a>PolynomialFactor </font></b><span style="font-family: Courier New;">(alias </span><b><font face="Agency FB" size="5">pfac</font></b><span style="font-family: Courier New;">)<br>
&nbsp; Numerical factorization of a polynomial, univariate or
multivariate<br>
&nbsp;<br>
&nbsp; Syntax: (pfac is the shortened alias for PolynomilaFactor)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt; s = PolynomialFactor(f)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt; s = PolynomialFactor(f, tol)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt; s = PolynomialFactor(f, tol, 'row')<br>
&nbsp;<br>
&nbsp; Input:&nbsp;&nbsp; f --- (string) polynomial<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
tol --- (numeric) coefficient error tolerance<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; style ---
(character) 'row' or anything else<br>
&nbsp;<br>
&nbsp; Output:&nbsp; p --- (cell array or string) the default
output p is a mx2 cell<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
where p{k,1} is the k-th factor with multiplicity p{k,2}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if the input item style = 'row', the output p is a string<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
in a row showing the factorization<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
res --- (numeric) residual, namely backward error<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
fcnd --- (numeric) condition number<br>
&nbsp;<br>
&nbsp;&nbsp; Example 1: Univariate factorization of (x-1)^20
(x-2)^15 (x-3)^10 (x-4)^5<br>
&nbsp;&nbsp; &gt;&gt; p =
ptimes(ppower('x-1',20),ppower('x-2',15),ppower('x-3',10),ppower('x-4',5))<br>
&nbsp;&nbsp; &gt;&gt; pfac(p)<br>
&nbsp;<br>
&nbsp;&nbsp; ans = <br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;
'x-4'&nbsp;&nbsp;&nbsp; [ 5]<br>
&nbsp;&nbsp;&nbsp;&nbsp;
'x-3'&nbsp;&nbsp;&nbsp; [10]<br>
&nbsp;&nbsp;&nbsp;&nbsp;
'x-2'&nbsp;&nbsp;&nbsp; [15]<br>
&nbsp;&nbsp;&nbsp;&nbsp;
'x-1'&nbsp;&nbsp;&nbsp; [20]<br>
&nbsp;<br>
&nbsp;&nbsp; Example 2: A multivariate factorization<br>
&nbsp;<br>
&nbsp;&nbsp;
&gt;&gt; p = '1125 + 1500*x*y*z + 500*x^2*y^2*z^2 +
675*x*y^3*z^2 +
900*x^2*y^4*z^3 + 300*x^3*y^5*z^4 + 135*x^2*y^6*z^4 + 180*x^3*y^7*z^5 +
60*x^4*y^8*z^6 + 9*x^3*y^9*z^6 + 12*x^4*y^10*z^7 + 4*x^5*y^11*z^8'<br>
&nbsp;<br>
&nbsp;&nbsp; &gt;&gt; G = pfac(pp,1e-10,'row')<br>
&nbsp;<br>
&nbsp;&nbsp; G =<br>
&nbsp;&nbsp; (1125) * (1 + 0.666666666666667*x*y*z)^2 * (1 +
0.2*x*y^3*z^2)^3<br>
<br>
</span><span style="font-family: Courier New;"></span><b><font face="Agency FB" size="5"><a name="pgcd"></a>PolynomialGCD
</font></b><span style="font-family: Courier New;">(alias
</span><b><font face="Agency FB" size="5">pgcd</font></b><span style="font-family: Courier New;">)<br>
&nbsp; Compute the numerical greatest common divisor of two
polynomials<br>
&nbsp;<br>
&nbsp; Syntax: (pgcd is the shortened alias of PolynomialGCD)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt; [u, v, w, residual, condition] = PolynomialGCD(f, g)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt; [u, v, w, residual, condition] = PolynomialGCD(f, g,
tol)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt; [u, v, w, residual, condition, p, q] =
PolynomialGCD(f, g)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt; [u, v, w, residual, condition, p, q] =
PolynomialGCD(f, g, tol)<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Input:&nbsp;&nbsp; f ---
(string)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
polynomial one<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
g ---
(string)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
polynomial two<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
tol --- (vector, optional)&nbsp; error tolerace in coefficients<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
with default 1.0e-10<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp; Output:&nbsp;&nbsp; u
--- (string)&nbsp; GCD of f and g<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
v --- (string)&nbsp; cofactor of f such that f = u*v<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
w --- (string)&nbsp; cofactor of g such that g = u*v<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
residual --- (numeric) backward error ||(f,g)-(u*v,u*w)||<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; condition
--- (numeric) sensitivity measure of the numerical GCD<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
p,q --- (strings) polynomials for p*f+q*g=u in univariate case <br>
&nbsp;<br>
&nbsp; Example:<br>
&nbsp; &gt;&gt; f = '-45*x*y - 15*x^3*y - 20*x*y^2 +
27*x*y^3 + 9*x^3*y^3 + 12*x*y^4';<br>
&nbsp; &gt;&gt; g = '45*x^2*y^2 + 15*x^2*y^3 - 27*x^2*y^4 -
9*x^2*y^5';<br>
&nbsp; &gt;&gt;&nbsp; [u,v,w,res,cond] =
PolynomialGCD(f,g);<br>
&nbsp; &gt;&gt;&nbsp; {u; v; w; res; cond}<br>
&nbsp;<br>
&nbsp; ans = <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
'-70*x*y + 42*x*y^3'&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
'0.642857142857143 + 0.214285714285714*x^2 + 0.285714285714286*y'<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
'-0.642857142857143*x*y - 0.214285714285714*x*y^2'<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[3.552713678800501e-014]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[&nbsp;&nbsp;&nbsp;&nbsp; 1.089132505368521]<br>
<br>
</span><b><font face="Agency FB" size="5"><a name="pplus"></a>PolynomialPlus</font></b><span style="font-family: Courier New;">(alias </span><b><font face="Agency FB" size="5">pplus</font></b><span style="font-family: Courier New;">)<br>
</span><br>
<span style="font-family: Courier New;">&nbsp;
Polynomial addition&nbsp; h = f1 + f2 + ... + fk<br>
&nbsp;<br>
&nbsp; Syntax:&nbsp;&nbsp; (pplus is the shortened alias
for PolynomialPlus)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt; p = PolynomialPlus(f,g)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt; p = PolynomialPlus(f,g,h)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt; p = PolynomialPlus(f1,f2,f3,f4)&nbsp; % etc<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp; Input:&nbsp;&nbsp;&nbsp; f,
g, h, ...&nbsp; --- (string or numeric) polynomials<br>
&nbsp;<br>
&nbsp;&nbsp; Output:&nbsp;&nbsp;&nbsp; p ---
(string) sum of the input polynomials<br>
&nbsp;<br>
&nbsp;&nbsp; Example: <br>
&nbsp;&nbsp; &gt;&gt;
PolynomialPlus('3+x^2','5*y^2+6*z^3','(5+3i)*x*z')<br>
&nbsp;<br>
&nbsp;&nbsp; ans =<br>
&nbsp;<br>
&nbsp;&nbsp; 3 + x^2 + 5*y^2 + (5+3i)*x*z + 6*z^3<br>
<br>
</span><b><font face="Agency FB" size="5"><a name="pminus"></a>PolynomialMinus</font></b><span style="font-family: Courier New;">(alias </span><b><font face="Agency FB" size="5">pminus</font></b><span style="font-family: Courier New;">)<br>
<br>
&nbsp; Polynomial subtraction&nbsp; h = f - g<br>
&nbsp;<br>
&nbsp; Syntax:&nbsp; &gt;&gt; h = PolynomialMinus(f,g)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
or&nbsp; &gt;&gt; h = pminus(f,g)<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp; Input:&nbsp;&nbsp;&nbsp; f
--- (string or numeric) polynomial one<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
g --- (string or numeric) polynomial two<br>
&nbsp;<br>
&nbsp;&nbsp; Output:&nbsp;&nbsp;&nbsp; h ---
(string) sum f-g<br>
&nbsp;<br>
&nbsp;&nbsp; Example:&nbsp; &gt;&gt;
PolynomialMinus('5*x^2*y+8','3*x^2*y+2')<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ans =<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
6 + 2*x^2*y<br>
<br>
<br>
<br>
</span><b><font face="Agency FB" size="5"><a name="psup"></a>PolynomialMinus</font></b><span style="font-family: Courier New;">(alias </span><b><font face="Agency FB" size="5">pminus</font></b><span style="font-family: Courier New;">)<br>
</span><br>
<span style="font-family: Courier New;">&nbsp;&nbsp;Extract
the support of input polynomial(s)<br>
&nbsp;<br>
&nbsp; Syntax: (psup is the shortened alias for PolynomialSupport)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt;&nbsp;&nbsp; F = PolynomialSupport(f)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt;&nbsp;&nbsp; F = PolynomialSupport(f,g)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt;&nbsp;&nbsp; F = PolynomialSupport(f,g,h)<br>
&nbsp;<br>
&nbsp; Input:&nbsp;&nbsp; f, g, h --- (strings) any number
of polynomial strings<br>
&nbsp;<br>
&nbsp; Output:&nbsp;&nbsp; F --- (cell) monomial support of
the input polynomials<br>
&nbsp;<br>
&nbsp; Example:&nbsp; &gt;&gt; f = '3 + 2*x*y +
5*x^2*y^3';<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt; g = '5+3*x*y-6*x^3*y^2';<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt; S = PolynomialSupport(f,g)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
S = <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
'1'&nbsp;&nbsp;&nbsp; 'x*y'&nbsp;&nbsp;&nbsp;
'x^3*y^2'&nbsp;&nbsp;&nbsp; 'x^2*y^3'<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<br>
</span><span style="font-family: Courier New;"><br>
<br>
</span><b><font face="Agency FB" size="5"><a name="ptimes"></a>PolynomialTimes</font></b><span style="font-family: Courier New;">(alias </span><b><font face="Agency FB" size="5">ptimes</font></b><span style="font-family: Courier New;">)</span><br>
&nbsp; Polynomial multiplication&nbsp; h = f1 * f2 * ... * fk<br>
&nbsp;<br>
&nbsp; Syntax:&nbsp;&nbsp; (ptimes is the shortened alias
for PolynomialTimes)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt; p = PolynomialTimes(f,g)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt; p = PolynomialTimes(f,g,h)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt; p = PolynomialTimes(f1,f2,f3,f4)&nbsp; % etc<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp; Input:&nbsp;&nbsp;&nbsp;
f,g,h,... --- (string or numeric) polynomials<br>
&nbsp;<br>
&nbsp;&nbsp; Output:&nbsp;&nbsp;&nbsp; p ---
(string) product of the input polynomials<br>
&nbsp;<br>
&nbsp;&nbsp; Example: <br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt; PolynomialTimes('2+x','3-y^2','4+x*z')<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ans =<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
24 - 8*y^2 + 12*x - 4*y^2*x + 6*x*z - 2*y^2*x*z + 3*x^2*z - y^2*x^2*z<br>
<br>
<br>
&nbsp;<b><font face="Agency FB" size="5"><a name="ppower"></a>PolynomialPower</font></b><span style="font-family: Courier New;">(alias </span><b><font face="Agency FB" size="5">ppower</font></b><span style="font-family: Courier New;">)<br>
</span><br>
<span style="font-family: Courier New;">&nbsp;
Polynomial power&nbsp; h = f^k<br>
&nbsp;<br>
&nbsp; Syntax:&nbsp; &gt;&gt; h = PolynomialPower(f,k)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
or&nbsp;&nbsp; &gt;&gt; h = ppower(f,k)<br>
&nbsp;<br>
&nbsp; Input:&nbsp;&nbsp;&nbsp;&nbsp; f ---
(string)&nbsp; polynomial<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
k --- (integer) exponent<br>
&nbsp;<br>
&nbsp; Output:&nbsp;&nbsp;&nbsp; h --- (string)
polynomial f^k if k is nonnegative<br>
&nbsp;<br>
&nbsp; Example:&nbsp;&nbsp; &gt;&gt;
PolynomialPower('x*y+1',3)<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ans =<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
1 + 3*x*y + 3*x^2*y^2 + x^3*y^3<br>
</span><b><font face="Agency FB" size="5"><a name="pnorm"></a>PolynomialNorm</font></b><span style="font-family: Courier New;">(alias </span><b><font face="Agency FB" size="5">pnorm</font></b><span style="font-family: Courier New;">)</span><br>
<span style="font-family: Courier New;"><br>
Polynomial multiplication&nbsp; ||f||_k <br>
&nbsp;<br>
&nbsp; Syntax:&nbsp; (pnorm is the shortened alias of
PolynomialNorm)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt; s = PolynomialNorm(f)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt; s = PolynomialNorm(f,k)<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp; Input:&nbsp;&nbsp; f --- (string
or numeric) polynomial <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
k --- 1, 2, or Inf<br>
&nbsp;<br>
&nbsp;&nbsp; Output:&nbsp;&nbsp; s --- (numeric) k-norm
of f<br>
&nbsp;<br>
<br>
</span><b><font face="Agency FB" size="5"><a name="pclear"></a>PolynomialClear</font></b><span style="font-family: Courier New;">(alias </span><b><font face="Agency FB" size="5">pclear</font></b><span style="font-family: Courier New;">)<br>
</span><br>
<span style="font-family: Courier New;">&nbsp;
Clear tiny coefficients, tiny real parts, and tiny imaginary parts<br>
&nbsp; from a polynomial<br>
&nbsp;<br>
&nbsp; Syntax:&nbsp; (pclear is the shortened alias of
PolynomialClear)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt; g = PolynomialClear(f)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt; g = PolynomialClear(f,tol)<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp; Input:&nbsp;&nbsp; f --- (string
or numeric) polynomial <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
tol ---
(numeric)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
threshold for being tiny<br>
&nbsp;<br>
&nbsp;&nbsp; Output:&nbsp;&nbsp; g --- (string or
numeric) cleared polynomial<br>
&nbsp;<br>
&nbsp;&nbsp; Example: <br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp; &gt;&gt;
PolynomialClear('(3+2e-13*i) + 2.1e-15*x*y+(1e-14+2*i)*x^3',1e-10)<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp; ans =<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp; 3 + (0+2i)*x^3<br>
<br>
</span><b><font face="Agency FB" size="5"><a name="PolynomialJacobian"></a>PolynomialJacobian</font></b><span style="font-family: Courier New;">(alias </span><b><font face="Agency FB" size="5">pjac</font></b><span style="font-family: Courier New;">)<br>
</span><br>
<span style="font-family: Courier New;">&nbsp;
Calculate the Jacobian of a polynomial system<br>
&nbsp;<br>
&nbsp; Syntax:&nbsp; (pjac is the shortened alias for
PolynomialJacobian)<br>
&nbsp;&nbsp;&nbsp; &gt;&gt; p =
PolynomialDerivative(F,z)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<br>
&nbsp;<br>
&nbsp;&nbsp; Input:&nbsp;&nbsp; F --- (cell) polynomial
system as a cell array of strings<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
z --- (string or cell)&nbsp;&nbsp;&nbsp; variable name(s)<br>
&nbsp;<br>
&nbsp; Output:&nbsp;&nbsp; J --- (cell) Jacobian of F<br>
&nbsp;<br>
&nbsp; Example:&nbsp; &gt;&gt;&nbsp; F = {'x +
y^2-3','x^2+z^4*y+5','x*z-6'}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt;&nbsp; J = PolynomiaJacobian(F,{'x','y','z'})<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
J = <br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
'1'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
'2*y'&nbsp;&nbsp;&nbsp;
'0'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
'2*x'&nbsp;&nbsp;&nbsp; 'z^4'&nbsp;&nbsp;&nbsp;
'4*z^3*y'<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
'z'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
'0'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
'x'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><br>
<span style="font-family: Courier New;"></span></li><li><b><font face="Agency FB" size="5"><a name="psolve"></a>psolve</font></b><span style="font-family: Courier New;"></span><span style="font-family: Courier New;"><br>
</span><br>
<span style="font-family: Courier New;">&nbsp; &nbsp;Numerical solution of polynomial systems by hom4ps Homotopy method <br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp; Syntax:&nbsp; &gt;&gt; [S, var] = psolve( P ) <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp; Input:&nbsp; P --- (cell array) the polynomial system to be solved<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; For example:&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt; P = {'-x^5+y^5-3*y-1','5*y^4-3','-20*x+y-z'}<br>&nbsp; <br>&nbsp;&nbsp; Output: S --- (matrix) numerical solutions (as columns of S)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var --- (cell array) the array of variables<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; For example, output<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
S = <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-0.8264 + 0.6004i&nbsp; -0.6092 - 1.0165i<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-0.8801 + 0.0000i&nbsp; -0.0000 - 0.8801i<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
15.6482 -12.0086i&nbsp; 12.1831 +19.4496i<br>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
var = {'x','y','z'}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
means there are two numerical solutions <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (x,y,z) = <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(-0.8264+0.6004i, -0.8801+0.0000i, 15.6482-12.0086i)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(-0.6092-1.0165i, -0.8801+0.0000i, 12.1831+19.4496i)<br>&nbsp;&nbsp;&nbsp;&nbsp; </span><br>
<span style="font-family: Courier New;"><br></span><br><span style="font-family: Courier New;">
<br>
</span><b><font face="Agency FB" size="5"><a name="TotalDegree"></a>TotalDegree<br>
</font></b><br>
<span style="font-family: Courier New;">&nbsp;&nbsp;
Extract the total degree from a polynomial string<br>
&nbsp;<br>
&nbsp; Syntax:&nbsp; &gt;&gt; d = TotalDegree(f)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt; d = TotalDegree(f,var)<br>
&nbsp;<br>
&nbsp; Input:&nbsp;&nbsp; f --- (string) polynomial<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
var --- (cell)&nbsp;&nbsp; optional, variable names <br>
&nbsp;<br>
&nbsp; Output:&nbsp; d --- (integer) total degree of f <br>
&nbsp;<br>
&nbsp; Example:&nbsp; &gt;&gt; p = '-2*x^2 + 9*x^3*y^2
- 9*x^4*y^2 + 8*x^5*y^2';<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt; TotalDegree(p)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ans =<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
7<br><br><br></span><b><font face="Agency FB" size="5"><a name="FactorDistance"></a>FactorDistance<br>
</font></b><br>
<span style="font-family: Courier New;">&nbsp; Calculate the distance between two factorizations <br>&nbsp;&nbsp;&nbsp; Given two factorizations stored in 2-column cells F and G,<br>&nbsp;&nbsp;&nbsp; where the 1st column contains the polynomial factors and<br>&nbsp;&nbsp;&nbsp; the 2nd column entries are corresponding multiplicities,<br>&nbsp;&nbsp;&nbsp; FactorDistance calculate their distance that is independent<br>&nbsp;&nbsp;&nbsp; of scaling, choice of representative and order of factors.<br>&nbsp; <br>&nbsp;&nbsp; Input:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; F --- (m x 2 cell array) <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
F{k,1}: the k-th factor of F as a string<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
F{k,2}: the multiplicity of the k-th factor<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; G --- (n x 2 cell array)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
G{k,1}: the k-th factor of G as a string<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
G{k,2}: the multiplicity of the k-th factor<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; permopt --- (string, optional)&nbsp; 'all':&nbsp; use all permulations<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
otherwise:&nbsp; the current order only<br>&nbsp;<br>&nbsp;&nbsp; Example:&nbsp;&nbsp; <br>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f = <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
'-4888'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[1]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'x*y-2*x+3*y-1'&nbsp;&nbsp;&nbsp; [3]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '3*y^2-5*x^3+4'&nbsp;&nbsp;&nbsp; [6]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g = <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
'16'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[1]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '352 + 264*y^2 - 440*x^3'&nbsp;&nbsp;&nbsp;&nbsp; [6]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '-6 - 12*x + 18*y + 6*x*y'&nbsp;&nbsp;&nbsp; [3]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt;&gt; FactorDistance(f,g)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ans =<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5.2663e-016</span><br><span style="font-family: Courier New;">
<br>
</span><b><font face="Agency FB" size="5"><a name="TupleDegree"></a>Tuple</font></b><b><font face="Agency FB" size="5">Degree</font></b><br>
<span style="font-family: Courier New;"><br>
&nbsp; Extract the total degree from a polynomial string<br>
&nbsp;<br>
&nbsp; Syntax:&nbsp; &gt;&gt; d = TupleDegree(f,var)<br>
&nbsp;<br>
&nbsp; Input:&nbsp;&nbsp; f --- (string) polynomial<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
var --- (cell)&nbsp;&nbsp; variable names in order<br>
&nbsp;<br>
&nbsp; Output:&nbsp; d --- (vector) tuple degree of f w.r.t. var<br>
&nbsp;<br>
&nbsp; Example:&nbsp; &gt;&gt; p = '-2*x^2 + 9*x^3*y^2
- 9*x^4*y^2 + 8*x^5*y^2';<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt; TupleDegree(p,{'x','y'})<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ans =<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
5<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
3<br>
<br>
</span><b><font face="Agency FB" size="5"><a name="prand"></a>RandomPolynomial</font></b><span style="font-family: Courier New;">(alias </span><b><font face="Agency FB" size="5">prand</font></b><span style="font-family: Courier New;">)</span><br>
<span style="font-family: Courier New;"><br>
&nbsp; Generate a random polynomial<br>
&nbsp;<br>
&nbsp; Syntax: &gt;&gt; p =
RandomPolynomial(variables,degree,terms)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or&nbsp;
&gt;&gt; p = prand(variables,degree,terms)<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp; Input:&nbsp; variables --- (cell or
string) variables<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
degree --- (integer or vector) tuple degree bound<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
for the random polynomial<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
terms --- (integer) number of terms<br>
&nbsp;<br>
&nbsp;&nbsp;
Output:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
p --- (string) random polynomial<br>
&nbsp;<br>
&nbsp; Example:&nbsp; &gt;&gt;&nbsp; p =
RandomPolynomial({'x','y'},[5,2],4)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
p = <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-2*x^2 + 9*x^3*y^2 - 9*x^4*y^2 + 8*x^5*y^2<br>
<br>
<br>
<br>
</span><b><font face="Agency FB" size="5"><a name="Multiplicity"></a>Multiplicity<br>
</font></b><span style="font-family: Courier New;"></span><br>
<span style="font-family: Courier New;">&nbsp;&nbsp;
Multiplicity --&gt; Computing the multiplicity and multiplicity
structure<br>
&nbsp;&nbsp; of a system of nonlinear equations at an isolated
zero.<br>
&nbsp;<br>
&nbsp;&nbsp; &lt;Synopsis&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
m = Multiplicity(f, variables, zero)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
m = Multiplicity(f, variables, zero, options)<br>
&nbsp;&nbsp; [m, D, H] = Multiplicity(f, variables, zero)<br>
&nbsp;&nbsp; [m, D, H] = Multiplicity(f, variables, zero,
options)<br>
&nbsp;<br>
&nbsp;&nbsp; &lt;Input Parameters&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;
1.
f&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
--&gt; a cell
array containing the system of nonlinear<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
equations as strings, e.g.,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt;&nbsp;&nbsp; f = { 'x^2 + sin(y) -1',&nbsp;
'x-cos(y)' };<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp; 2. variables --&gt; a cell
array containing the unknown variables as<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
strings, e.g.,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt;&nbsp;&nbsp; variables = { 'x',&nbsp; 'y' };<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp; 3.
zero&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --&gt; a
vector containing numerical zero (root) of f, e.g.,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt;&nbsp;&nbsp; zero = [1, 0];<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp; 4. options&nbsp;&nbsp;
--&gt; an optional parameter which includes the configuration<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
settings:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Display: Set to 2 to have all output (the dual space<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
and Hilbert function) printed to the screen,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
and set to 1 to have depth and Hilbert<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
function printed to the screen. Otherwise<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
set the default value 0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Tol: The threshold for numerical rank-revealing.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Singular values above Tol are counted as<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
nonzero. The default value is 1e-8;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
EqnType: The equation type for Multiplicity,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
polynomial system ('Poly') or nonlinear<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
functions ('Nonlinear'). The default value is<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
'Nonlinear'. By setting the value to 'Poly',<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Multiplicity will transfer the polynomial<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
system to the matrix representation<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
internally and speed up the computation.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
MaxInt: Maximum multiplicity allowed in the recursive<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
computation. If a zero is not isolated, the<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
multiplicity will be infinity.&nbsp; The code can<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
be used for identifying a nonisolated zero by<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
setting MaxInt to a known upper bound (e.g.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
the Bezout number). The default value is 1000.<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
All the configuration settings may be changed by using<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
optset function, i.e.,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt;&nbsp;&nbsp; options = optset('para', value);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
para could be any configuration setting, value is set<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
to para. See OPTSET for details. Any configuration<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
setting that is not changed will be set to its default<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
value.<br>
&nbsp;<br>
&nbsp;&nbsp; &lt;Output Parameters&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp; 1.
m&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
--&gt; the multiplicity of f at the zero;<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp; 2.
D&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
--&gt; a basis for the dual space as a cell array with<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
each component being a matrix in the Matlab form of<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
D{i} = [c_1, j_1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
c_2, j_2;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
...<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
c_n, j_n ];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
representing a differential functional<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
D_i = c_1*d_{j_1} + ... + c_n*d_{j_n}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
where d_{j_i}'s are differential monomial functionals<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(e.g. For a system of equations with variables {x,y,z}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
at the zero x=a, y=b, z=c, the functional d_{[i,j,k]}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
applied to any function g is the value of the partial<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
derivative<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
i+j+k<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
d<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
d_{[i,j,k]}(g) = -------- * ----------- g(a,b,c)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
i! j! k!&nbsp;&nbsp;&nbsp;&nbsp; i&nbsp;&nbsp;
j&nbsp;&nbsp; k<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
dx&nbsp; dy&nbsp; dz<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
The dual space is the vector space consists of such<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
differential functionals that vanish on the nonlinear<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
system while satisfying the so-called closedness<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
condition);<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp; 3.
H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
--&gt; values of the Hilbert function in a vector.<br>
&nbsp;<br>
&nbsp;&nbsp; &lt;Examples&gt;<br>
&nbsp;&nbsp;&nbsp; Consider the nonlinear system<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
sin(x)*cos(y)-x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
= 0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
sin(y)*sin(x)^2 - y^2 = 0<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp; at the zero (x, y) = (0, 0), the
multiplicity can be computed by the<br>
&nbsp;&nbsp;&nbsp; following statements:<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt;&gt; f =
{'sin(x)*cos(y) - x', 'sin(y)*sin(x)^2 - y^2'};<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt;&gt;
variables = {'x', 'y'};<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt;&gt;
zero = [0, 0];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt;&gt; m =
Multiplicity(f, variables, zero)<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp; To create an options structure with Tol
= 1e-10, MaxInt = 100:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt;&gt;
options = optset('Tol', 1e-10, 'MaxInt', 100);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt;&nbsp; m = Multiplicity(f, variables, zero, options)<br>
&nbsp;<br>
&nbsp;&nbsp; &lt;Algorithm&gt;<br>
&nbsp;&nbsp;&nbsp; This code implements a modified
closedness subspace method for<br>
&nbsp;&nbsp;&nbsp; multiplicity identification with a newly
developed equation-by-equation<br>
&nbsp;&nbsp;&nbsp; strategy for improving efficiency.<br>
&nbsp;<br>
&nbsp;&nbsp; &lt;References&gt;<br>
&nbsp;&nbsp; [1] An algorithm and software for computing
multiplicity structures at<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; zeros of
nonlinear systems, W. Hao, A. J. Sommesse and Z. Zeng<br>
&nbsp;&nbsp; [2] The closedness subspace method for computing
the multiplicity<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; structure
of a polynomial system, Z. Zeng.<br>
&nbsp;<br>
&nbsp;&nbsp; See also optset, cell<br><br><br></span><b><font face="Agency FB" size="5"><a name="ShowDual"></a>ShowDual<br>
</font></b><br>
<span style="font-family: Courier New;">&nbsp; Display a basis for dual space D computed by Multiplicity<br>&nbsp;<br>&nbsp;&nbsp; Syntax:&nbsp; ShowDual(D)<br>&nbsp;<br>&nbsp;&nbsp; Input:&nbsp;&nbsp; D --- (cell array) the basis of dual space computed by the<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
function Multiplicity<br>&nbsp;<br>&nbsp; Output:&nbsp;&nbsp; Screen display of the dual basis<br>&nbsp;<br>&nbsp;&nbsp; Example:&nbsp; &gt;&gt; [m,D,H] = Multiplicity({'x^2+sin(y^2)-2*x+1', 'x-cos(y)'}, ...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{'x','y'}, [1,0] )<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt;&gt; ShowDual(D)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
d00 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
d01 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0.447214*d10 -0.894427*d02 <br>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-0.816497*d03 +0.408248*d11 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family: Courier New;"><br>
</span><b><font face="Agency FB" size="5"><a name="MacaulayMatrix"></a>MacaulayMatrix</font></b><br><span style="font-family: Courier New;">Construct the Macaulay matrix of a polynomial ideal at an <br>&nbsp;&nbsp;&nbsp; isolated zero<br>&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; Syntax:&nbsp; &gt;&gt; M = MacaulayMatrix(z, P, var, depth);<br>&nbsp;<br>&nbsp; Input:&nbsp; z --- (1xn vector) the isolated zero<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; P --- (1xm cell) the polynomials generating the ideal<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var --- (1xn cell) variable names of the ideal <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; depth --- (integer) depth (differential order) of the Macaulay matrix<br>&nbsp;<br>&nbsp; Output&nbsp; M --- the Macaulay matrix in sparse format<br>&nbsp;<br>&nbsp;&nbsp;&nbsp; Example:&nbsp; For an approximate zero x = 0.57735, y = 0.57735 to the system<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x^3+y-0.7698 = 0,&nbsp;&nbsp;&nbsp;&nbsp; x+y^3-0.7698 = 0<br>&nbsp;&nbsp;&nbsp; the call sequence<br>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt;&gt; z = [0.57735,0.57735];&nbsp; P = {'x^3+y-0.7698','x+y^3-0.7698'}; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt;&gt; var = {'x','y'};&nbsp; depth = 2; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt;&gt; M = MacaulayMatrix(z, P, var, depth)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; generates the Macaulay matrix of depth 2.<br>
<br>
</span><b><font face="Agency FB" size="5"><a name="ConvolutionMatrix"></a>ConvolutionMatrix<br>
</font></b><br>
<span style="font-family: Courier New;">&nbsp;&nbsp;
Generate an n-column convolution matirx of .<br>
&nbsp;&nbsp; An n-column convolution matrix of p is the matrix
for the <br>
&nbsp;&nbsp; linear transformation L(f) = p*f&nbsp; for
polynomial f of degree n-1.<br>
&nbsp;&nbsp; If f is the coefficient vector of f, and C is the
convolution matrix,<br>
&nbsp;&nbsp; then C*f is the coefficient vector of p*f.<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp; Syntax:&nbsp; C =
ConvolutionMatrix(p,n)<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp; Input:&nbsp;&nbsp; p
--- (string or vector) the univariate polynomial<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
n --- (integer) the column dimension of the convolution matrix<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp; Output:&nbsp;&nbsp; C --- the
convolution matrix<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp; Example:&nbsp; &gt;&gt; p =
'1+3*x^4-6*x^8';<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt; C = ConvolutionMatrix(p,3)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
C =<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-6&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp; 0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;
-6&nbsp;&nbsp;&nbsp;&nbsp; 0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp; -6<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp; 0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
3&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp; 0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;
3&nbsp;&nbsp;&nbsp;&nbsp; 0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp; 3<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp; 0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
1&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp; 0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;
1&nbsp;&nbsp;&nbsp;&nbsp; 0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp; 1<br>
<br>
</span><b><font face="Agency FB" size="5"><a name="SylvesterMatrix"></a>SylvesterMatrix</font></b><br>
<span style="font-family: Courier New;"><br>
&nbsp;&nbsp; generate the k-th Sylverster matrix of f and g<br>
&nbsp;&nbsp; The k-th Sylvester matrix is the matrix of the
linear transformation<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; L(v,w) = f*w+g*v<br>
&nbsp;&nbsp; for deg(v) = deg(f)-k,&nbsp; deg(w) =
deg(g)-k.&nbsp; <br>
&nbsp;&nbsp; The default value for k is k=1 if not provided,
which is the most<br>
&nbsp;&nbsp;&nbsp; well-known Sylvester matrix.<br>
&nbsp;<br>
&nbsp;&nbsp; Syntax:&nbsp;&nbsp; &gt;&gt; S =
SylvesterMatrix(f,g)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt; S = SylvesterMatrix(f,g,k)<br>
&nbsp;<br>
&nbsp;&nbsp; Input:&nbsp;&nbsp; f, g --- (strings or
coefficient vectors) polynomials<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
k --- (integer, optional) see above<br>
&nbsp;<br>
&nbsp;&nbsp; Output:&nbsp;&nbsp;&nbsp;&nbsp; S
--- (matrix) The Sylvester matrix<br>
&nbsp;<br>
&nbsp;&nbsp; Example:&nbsp; &gt;&gt;
SylvesterMatrix('1+3*x-6*x^3','2+5*x^2')<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ans =<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-6&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;
5&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp; 0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;
-6&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;
5&nbsp;&nbsp;&nbsp;&nbsp; 0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
3&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;
2&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp; 5<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
1&nbsp;&nbsp;&nbsp;&nbsp;
3&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;
2&nbsp;&nbsp;&nbsp;&nbsp; 0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;
1&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp; 2<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt; SylvesterMatrix('1+3*x-6*x^3','2+5*x^2',2)<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ans =<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-6&nbsp;&nbsp;&nbsp;&nbsp;
5&nbsp;&nbsp;&nbsp;&nbsp; 0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp; 5<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
3&nbsp;&nbsp;&nbsp;&nbsp;
2&nbsp;&nbsp;&nbsp;&nbsp; 0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
1&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp; 2<br><br><br></span><b><font face="Agency FB" size="5"><a name="BezoutMatrix"></a>BezoutMatrix</font></b><br>
<span style="font-family: Courier New;"><br>&nbsp;&nbsp; generate the Bezout matrix B_n (f,g) of polynomials f and g <br>&nbsp;&nbsp;&nbsp;&nbsp; that is defined so that<br>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f(x)*g(y)-f(y)*g(x)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ------------------- = [1,x,...,x^(n-1)]*B_n(f,g)*[1,y,...,y^(n-1)]'<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x - y<br>&nbsp;<br>&nbsp;&nbsp; Syntax:&nbsp;&nbsp; &gt;&gt; B = BezoutMatrix(f,g)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt;&gt; B = BezoutMatrix(f,g,n)<br>&nbsp;<br>&nbsp;&nbsp; Input:&nbsp;&nbsp; f, g --- (strings or coefficient vectors) polynomials<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
n --- (integer, optional) size of the Bezout matrix, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
can not be smaller than either degrees of f or g<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
default value is the larger degree of f and g<br>&nbsp;<br>&nbsp;&nbsp; Output:&nbsp;&nbsp;&nbsp;&nbsp; B --- (matrix) The Bezout matrix<br>&nbsp;<br>&nbsp;&nbsp; Example:&nbsp; &gt;&gt; BezoutMatrix('3*x^3-x','5*x^2+1')<br>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ans =<br>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-1&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; 3<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp;&nbsp;&nbsp; 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
3&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp; 15<br>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt;&gt; BezoutMatrix('3*x^3-x','5*x^2+1',4)<br>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ans =<br>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-1&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;
3&nbsp;&nbsp;&nbsp;&nbsp; 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp; 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
3&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;
15&nbsp;&nbsp;&nbsp;&nbsp; 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp; 0<br><br></span><b><font face="Agency FB" size="5"><a name="CompanionMatrix"></a>CompanionMatrix</font></b><br>
<span style="font-family: Courier New;"><br>&nbsp;&nbsp; generate the Companion matrix of the polynomials f <br>&nbsp;<br>&nbsp;&nbsp; Syntax:&nbsp;&nbsp; &gt;&gt; B = CompanionMatrix(f)<br>&nbsp;<br>&nbsp;&nbsp; Input:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f --- (string or coefficient vector) polynomial<br>&nbsp;<br>&nbsp;&nbsp; Output:&nbsp;&nbsp;&nbsp;&nbsp; C --- (matrix) The companion matrix<br>&nbsp;<br>&nbsp;&nbsp; Example:&nbsp; &gt;&gt; CompanionMatrix('x^4 + 2*x^3 + 3*x^2 + 4*x+5')<br>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ans =<br>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-2&nbsp;&nbsp;&nbsp; -3&nbsp;&nbsp;&nbsp; -4&nbsp;&nbsp;&nbsp; -5<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
1&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp; 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp; 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;
1&nbsp;&nbsp;&nbsp;&nbsp; 0</span><br><span style="font-family: Courier New;">
<br>
<br>
<br>
</span><b><font face="Agency FB" size="5"><a name="LinearTransformMatrix"></a>LinearTransformMatrix<br>
</font></b><br>
<span style="font-family: Courier New;">&nbsp;&nbsp;
Generic routine for generating the linear transformation matrix<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp; Syntax:&nbsp; M =
LinearTransformMatrix(@F, DR, para)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[M,Range] = LinearTransformMatrix(@F, DR, para)<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp; Input:&nbsp; F&nbsp;
-- Matlab function name for calculate the Lin. Transf.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
with syntax&nbsp; F(P,Q1,...,Qk) where P is the polyn.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
to be transformed by the linear transformation.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
the remaining parameters Q1,...,Qk must be <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
provided as cell entries for para.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(If the basis for the domain consists only <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
monomials, F needs to be implemented on monomials<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
only.) <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DR&nbsp; -- (cell) domain and range information<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
default:&nbsp; DR = {D, dR} where D is a matrix <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
representing the monomial basis. Each column<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
of D represents a monomial.&nbsp; dR is the tuple<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
degree bound for the range as a vector space<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
consisting all the polynomials with tuple degree<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
within dR.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
para&nbsp; -- (cell) parameters needed for running F<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp; Output:&nbsp;&nbsp; M&nbsp;
-- the (sparse) matrix for the linear transformation<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Range&nbsp; -- (optional) the fewnomial basis for the range, if it<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
is needed<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp; Example:&nbsp; Let T be the linear
transformation&nbsp; g -&gt; f*g&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
in the domain {x*y^3*z^2, x^2*z^4, y^5*z}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
where f = x^2*z^3 + 5*x*y^4*z^6<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1. Write a code:<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
function G = MonomialMultiplyByF(M,F)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
%<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
%&nbsp; function for calculating a monomial multiplied <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
%&nbsp;&nbsp;&nbsp;&nbsp; by a polynomial<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
%<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
%&nbsp;&nbsp;&nbsp; input:&nbsp;&nbsp; M -- a
monomial in a one-column
coefficient <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
matrix<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
F -- a polynomial in a coefficient matrix<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
%<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
m = size(M,1)-1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
G = F;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
for k = 1:m<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
G(k,:) = F(k,:) + M(k);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
end<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp; 2. Prepare input<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<br>
&nbsp;&nbsp;&nbsp;&nbsp; &gt;&gt; D = [[1; 3;
2], [2; 0; 4], [0; 5; 1]];<br>
&nbsp;&nbsp;&nbsp;&nbsp; &gt;&gt; dR = [4; 9;
10];<br>
&nbsp;&nbsp;&nbsp;&nbsp; &gt;&gt; F = [[1; 0;
3; 1], [1; 4; 6; 5]];<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp; 3a. Execute with one output
item requested:<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp; &gt;&gt; M =
LinearTransformMatrix(@MonomialMultiplyByF,{D,dR},{F});<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
M =<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(268,1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(438,1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
5<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(354,2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(524,2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
5<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(227,3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(397,3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
5<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp; 3b Execute with two output
items requested<br>
&nbsp;&nbsp;&nbsp; &gt;&gt; [M, R] =
LinearTransformMatrix(@MonomialMultiplyByF,{D,dR},{F})<br>
&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; M =<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(2,1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(5,1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
5<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(3,2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(6,2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
5<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(1,3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(4,3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
5<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; R =<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
2&nbsp;&nbsp;&nbsp;&nbsp;
3&nbsp;&nbsp;&nbsp;&nbsp;
4&nbsp;&nbsp;&nbsp;&nbsp;
2&nbsp;&nbsp;&nbsp;&nbsp;
3&nbsp;&nbsp;&nbsp;&nbsp; 4<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
5&nbsp;&nbsp;&nbsp;&nbsp;
3&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;
9&nbsp;&nbsp;&nbsp;&nbsp;
7&nbsp;&nbsp;&nbsp;&nbsp; 4<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
4&nbsp;&nbsp;&nbsp;&nbsp;
5&nbsp;&nbsp;&nbsp;&nbsp;
7&nbsp;&nbsp;&nbsp;&nbsp;
7&nbsp;&nbsp;&nbsp;&nbsp;
8&nbsp;&nbsp;&nbsp;
10<br>
<br>
<br>
</span><b><font face="Agency FB" size="5"><a name="GaussNewton"></a>GaussNewton<br>
</font></b><br>
<span style="font-family: Courier New;">&nbsp; &nbsp; Generic Gauss-Newton iteration routine for the least squares solution of<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; F(z) = 0<br>&nbsp; for z in a vector space domain <br>&nbsp;<br>&nbsp;&nbsp;&nbsp; There are two versions: <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (i) generic version: solution consists of components of vectors, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matrices and polynomials.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (ii) column vector version: Iterates on column vectors<br>&nbsp;<br>&nbsp;&nbsp;&nbsp; Syntax of version (i)&nbsp; i.e. generic version:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [z,res,fcond] = GaussNewton({@F,domain,para}, @G, z0) <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [z,res,fcond] = GaussNewton({@F,domain,para}, @G, z0, trac) <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [z,res,fcond] = GaussNewton({@F,domain,para}, @G, z0, trac, tol)<br>&nbsp;<br>&nbsp;&nbsp;&nbsp; Input:&nbsp;&nbsp; F -- (function) Matlab function name for calculating y = F(z)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
with syntax &gt;&gt; y = F(z1,...zk,p1,...,pm) where z1,...,zk<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
are components of z and p1,...,pm are fixed parameters.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(F must run on F(domain{:},para{:}).<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; domain -- domain of the homomorphism represented by<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(i) an mxn matrix of 0' and 1's representing<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0 entries and variable entries respectively, or<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(ii) a polynomial with variable coefficients being <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
nonzero, or<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(iii) a cell array of matrices in (i) and/or (ii)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
assuming the domain is a product of matrix spaces and<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
polynomial spaces<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; para -- (cell) parameters needed for running F<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
G -- (function) Matlab function name for calculating the <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Jacobian u = F_z(z0)y F as a homomorphism with syntax<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt; u = G(y1,...,yk,z1,...zk,p1,...,pm) <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
where z1,...,zk,p1,...,pk are the same for F but<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
considered fixed, the variables are y1,...,yk in the<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
same domain of F. <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
z0 -- (cell/matrix/polynomial) the initial iterate for the<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Gauss-Newton iteration in the domain<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trac -- (0,1,or 2, optional) flag for tracking the iteration<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if tracking = 0 or missing, no tracking<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if tracking = 1, track the first component z1 of z<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if tracking = 2, track all components of z<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
tol -- (numeric, optional) error tolerance of the iterate<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if missing, iteration stops when residule stops<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; decreasing<br>&nbsp;<br>&nbsp; Output:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; z&nbsp; -- the least squares solution in the domain<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
res&nbsp; -- (optional) the residual ||F(z)||<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fcond&nbsp; -- (optional) the condition number<br>&nbsp;<br>&nbsp;<br>&nbsp; Syntax: column vector version <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [z,res,fcond] = GaussNewton(@Func, @Jacb, z0, {p1,...,pn},trac)<br>&nbsp;<br>&nbsp; Input:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Func&nbsp; -- Matlab function name for F(z)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Jacb&nbsp; -- Matlab function name for the Jacobian J(z) of F(z)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
both Func and Jacb must be written to accept input<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
z0 along with other parameters p1, p2, ..., pn<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
z0&nbsp; -- (column vector) the initial iterate<br>&nbsp;&nbsp;&nbsp; {p1,p2,...,pn}&nbsp; -- (cell) parameters for Func and Jacb<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trac&nbsp; -- tracking flag, 0, or 1<br>&nbsp;<br>&nbsp; Output:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; z&nbsp; -- the least squares solution<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
res&nbsp; -- (optional) the residual ||F(z)||<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fcond&nbsp; -- (optional) the condition number<br>&nbsp;<br>&nbsp; <br>&nbsp; Syntax of version (ii), i.e. column vector version:&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [z,res,fcond] = GaussNewton(@Func, @Jacb, z0, {p1,...,pn},trac)<br>&nbsp;<br>&nbsp; Input:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Func&nbsp; -- Matlab function name for F(z)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Jacb&nbsp; -- Matlab function name for the Jacobian J(z) of F(z)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
both Func and Jacb must be written to accept input<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
z0 along with other parameters p1, p2, ..., pn<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
z0&nbsp; -- the initial iterate vector<br>&nbsp;&nbsp;&nbsp; {p1,p2,...,pn}&nbsp; -- (cell) vector parameters for Func and Jacb<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trac&nbsp; -- tracking flag, 0, or 1<br>&nbsp;<br>&nbsp; Output:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; z&nbsp; -- the least squares solution vector<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
res&nbsp; -- (optional) the residual ||F(z)||<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fcond&nbsp; -- (optional) the condition number<br>&nbsp;<br></span><b><font face="Agency FB" size="5"><a name="Newton"></a>Newton<br>
</font></b><br>
<span style="font-family: Courier New;">&nbsp; Generic rank-r Newton's iteration routine solving&nbsp;&nbsp;&nbsp; F(z) = 0&nbsp; where<br>&nbsp; F is a smooth mapping between vector spaces, assuming the Jacobian<br>&nbsp; is of rank r at the solution that can be non-isolated<br>&nbsp; (c.f. http://homepages.neiu.edu/~zzeng/Papers/Rank-r_Newton.pdf)<br>&nbsp;<br>&nbsp;&nbsp;&nbsp; Syntax <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [z,res,fcond] = Newton({@F,domain,para}, @G, z0) <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [z,res,fcond] = Newton({@F,domain,para}, @G, z0, trac) <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [z,res,fcond] = Newton({@F,domain,para}, @G, z0, trac, tol)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [z,res,fcond] = Newton({@F,domain,para}, {@G,r}, z0) <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [z,res,fcond] = Newton({@F,domain,para}, {@G,r}, z0, trac) <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [z,res,fcond] = Newton({@F,domain,para}, {@G,r}, z0, trac, tol)<br>&nbsp;<br>&nbsp;&nbsp;&nbsp; Input:&nbsp;&nbsp; F -- (function) Matlab function name for calculating y = F(z)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
with syntax &gt;&gt; y = F(z1,...zk,p1,...,pm) where z1,...,zk<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
are components of z and p1,...,pm are fixed parameters.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(F must run on F(domain{:},para{:}).<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; domain -- domain of the homomorphism represented by<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(i) an mxn matrix of 0' and 1's representing<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0 entries and variable entries respectively, or<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(ii) a polynomial with variable coefficients being <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
nonzero, or<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(iii) a cell array of matrices in (i) and/or (ii)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
assuming the domain is a product of matrix spaces and<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
polynomial spaces<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; para -- (cell) parameters needed for running F<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
G -- (function) Matlab function name for calculating the <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Jacobian u = F_z(z0)y F as a homomorphism with syntax<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt; u = G(y1,...,yk,z1,...zk,p1,...,pm) <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
where z1,...,zk,p1,...,pk are the same for F but<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
considered fixed, the variables are y1,...,yk in the<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
same domain of F. <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
r -- (integer, optional) if provided, the rank-r projection<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
of the Jacobian is used for the iteration<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
z0 -- (cell/matrix/polynomial) the initial iterate for the<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Newton's iteration in the domain<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trac -- (0,1,or 2, optional) flag for tracking the iteration<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if tracking = 0 or missing, no tracking<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if tracking = 1, track the first component z1 of z<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if tracking = 2, track all components of z<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
tol -- (numeric, optional) error tolerance of the iterate<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if missing, iteration stops when residule stops<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; decreasing<br>&nbsp;<br>&nbsp; Output:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; z&nbsp; -- the least squares solution in the domain<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
res&nbsp; -- (optional) the residual ||F(z)||<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fcond&nbsp; -- (optional) the condition number<br>&nbsp;<br>&nbsp;</span><br><span style="font-family: Courier New;">
<br>
<br>
</span><b><font face="Agency FB" size="5"><a name="PolynString2CoefMat"></a>PolynString2CoefMat<br>
</font></b><br>
<span style="font-family: Courier New;">&nbsp;&nbsp;
convert a polynomial string to a coefficient matrix<br>
&nbsp;<br>
&nbsp; Syntax: &gt;&gt; F = PolynString2CoefMat(f,var)<br>
&nbsp;<br>
&nbsp; Input:&nbsp;&nbsp;&nbsp; f --- (string)
polynomial string<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
var --- (cell) variable names in order<br>
&nbsp;<br>
&nbsp; Output:&nbsp;&nbsp; F --- (matrix) polynomial in
coefficient matrix<br>
&nbsp;<br>
&nbsp; Example:&nbsp; &gt;&gt; p = '6*x^2*y + 8*y^3';<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt; PolynString2CoefMat(p,{'x','y'})<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ans =<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
2&nbsp;&nbsp;&nbsp;&nbsp; 0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
1&nbsp;&nbsp;&nbsp;&nbsp; 3<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
6&nbsp;&nbsp;&nbsp;&nbsp; 8<br>
<br>
</span><b><font face="Agency FB" size="5"><a name="CoefMat2PolynString"></a>CoefMat2PolynString<br>
</font></b><br>
<span style="font-family: Courier New;">&nbsp;
Convert a polynomial coefficient matrix to a polynomial string<br>
&nbsp; <br>
&nbsp; Syntax:&nbsp; &gt;&gt; p =
CoefMat2PolynString(F,var)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt; p = CoefMat2PolynString(F,var,digits)<br>
&nbsp;<br>
&nbsp; Input:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; F
--- (matrix) Coefficient matrix of a polynomial<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
var --- (cell)&nbsp;&nbsp; variable names in order<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
digits --- (integer) optional, number of digits, default = 15<br>
&nbsp;<br>
&nbsp; Output:&nbsp;&nbsp;&nbsp;&nbsp; p ---
(string) polynomial as a string<br>
&nbsp; <br>
&nbsp; Example:&nbsp; &gt;&gt; F = [2 0; 1 3; 6, 8]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
F =<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
2&nbsp;&nbsp;&nbsp;&nbsp; 0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
1&nbsp;&nbsp;&nbsp;&nbsp; 3<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
6&nbsp;&nbsp;&nbsp;&nbsp; 8<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt; CoefMat2PolynString(F,{'x','y'})<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ans =<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
6*x^2*y + 8*y^3<br>
&nbsp;<br>
</span><b><font face="Agency FB" size="5"><a name="uvGCDfixedDegree"></a>uvGCDfixedDegree</font></b><br>
<span style="font-family: Courier New;"><br>
&nbsp; uvGCDfixedDegree computes the numerical greatest common
divisor of a given<br>
&nbsp; polynomial pair (f,g) with a given GCD degree<br>
&nbsp; <br>
&nbsp; Syntax: <br>
&nbsp;<br>
&nbsp;&nbsp; &gt;&gt; [u,v,w,res,cond] =
uvGCDfixedDegree(f,g,k)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<br>
&nbsp;<br>
&nbsp; Input&nbsp;&nbsp; f, g -- the polynomial pairs as
coefficient vectors<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
tol -- (optional) the residual tolerance, default: 1e-10<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
k -- the GCD degree<br>
&nbsp;<br>
&nbsp; Output&nbsp;&nbsp;&nbsp;&nbsp; u,v,w -- the
numerical GCD triplet such that <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
conv(u,v) approximates f, conv(u,w) approximates g<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
res -- the (weighted) residual<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
cond -- the numerical GCD condition number<br>
&nbsp;<br>
&nbsp; Example:<br>
&nbsp;<br>
&nbsp;&nbsp; &gt;&gt; f = [1&nbsp; 3&nbsp; 6 10
10&nbsp; 9&nbsp; 7&nbsp; 4];<br>
&nbsp;&nbsp; &gt;&gt; g = [1&nbsp; 6 10 13
15&nbsp; 15 10&nbsp; 6&nbsp; 3&nbsp; 1];<br>
&nbsp;&nbsp; &gt;&gt; [u,v,w,res,cond] =
uvGCDfixedDegree(f,g,4)<br>
<br>
<br>
<br>
</span><b><font face="Agency FB" size="5"><a name="mvPolynCoefMat2Vec"></a>mvPolynCoefMat2Vec<br>
</font></b><br>
<span style="font-family: Courier New;">&nbsp;&nbsp;
Convert a coefficient matrix to a (sparse) coefficient vector<br>
&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp; Syntax:&nbsp;
&gt;&gt; v = mvPolynCoefMat2Vec(F)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt; v = mvPolynCoefMat2Vec(F,d)<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;
Input:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; F --
multivariate polynomials in coeff. matrix<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
d -- (optional) degree bound for the polynomial vector space<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if not provided, the tuple degree of F is used<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
to be added: the case when d is total degree<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;
Output:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v -- (sparse
vector) the coefficient vector<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp; Example:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt; F = PolynString2CoefMat('3 + 5.5*x^2 -
7*x*y^3',{'x','y'})<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; F =<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp; 2.0000&nbsp;&nbsp;&nbsp;
1.0000<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;
3.0000<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
3.0000&nbsp;&nbsp;&nbsp; 5.5000&nbsp;&nbsp; -7.0000<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt; f = mvPolynCoefMat2Vec(F)<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ans =<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(1,1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3.0000<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(3,1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5.5000<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(11,1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -7.0000<br>
<br>
</span><b><font face="Agency FB" size="5"><a name="mvPolynCoefVec2Mat"></a>mvPolynCoefVec2Mat</font></b><br>
<span style="font-family: Courier New;"><br>
&nbsp; Convert a multivariate coefficient vector to coefficient
matrix<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp; Syntax:&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt; F = mvPolynCoefVec2Mat(f,d)&nbsp; <br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Input:&nbsp;&nbsp;&nbsp; f -- coefficient vector of a
multivariate polynomial <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
d -- tuple degree of the multivariate polynomial<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;
Output:&nbsp;&nbsp;&nbsp; F -- the coefficient matrix of
the multivariate polynomial<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp; Example:<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt; f<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f =<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(1,1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3.0000<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(3,1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5.5000<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(11,1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -7.0000<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt; mvPolynCoefVec2Mat(f,[2,3])<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ans =<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp; 2.0000&nbsp;&nbsp;&nbsp;
1.0000<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;
3.0000<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
3.0000&nbsp;&nbsp;&nbsp; 5.5000&nbsp;&nbsp; -7.0000<br>
<br>
</span><b><font face="Agency FB" size="5"><a name="mvPolynIndexer"></a>mvPolynIndexer<br>
</font></b><br>
<span style="font-family: Courier New;">&nbsp;&nbsp;
function for generating monomial indexer s = [s(1),...,s(m)].<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Given an m-tuple
degree bounded d = [d(1),...,d(m)], a monomial of<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; degree p = [p(1);
...; p(m)] is the k-th monomial in lexcographical <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; order where<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
k = 1 + s*p<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp; Syntax:&nbsp;
&gt;&gt; s = mvPolynIndexer(d)<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;
Input:&nbsp;&nbsp;&nbsp;&nbsp; d --- (vector) an
m-degree<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<br>
&nbsp;&nbsp;&nbsp;
Output:&nbsp;&nbsp;&nbsp;&nbsp; s --- (row vector) the
indexer<br>
<br>
<br>
</span><b><font face="Agency FB" size="5"><a name="mvPolynMonomTotal"></a>mvPolynMonomTotal<br>
</font></b><br>
<span style="font-family: Courier New;">&nbsp;
Calculate the monomial count within given degree and number of variables<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp; Syntax:&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt; n = mvPolynMonomTotal(d)&nbsp;&nbsp;&nbsp;
% if d is a tuple degree<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt; n = mvPOlynMonomTotal(d,m)&nbsp; % total degree d
with m variables<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Input:&nbsp;&nbsp;&nbsp; d -- tuple degree or total degree<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
m -- number of varialbles for total degree<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp; Output:&nbsp; the number
of monomials within the degree d<br>
<br>
<br>
</span><b><font face="Agency FB" size="5"><a name="mvPolynMonomBasis"></a>mvPolynMonomBasis<br>
</font></b><br>
<span style="font-family: Courier New;">&nbsp;&nbsp;
Generate the monomial basis<br>
&nbsp;<br>
&nbsp;&nbsp; Input:&nbsp;&nbsp; d --- degree bound<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
n --- (optional) number of variables if d is<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
total degree<br>
&nbsp;<br>
&nbsp;&nbsp; Output:&nbsp; B --- the coefficient matrix
whose columns <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
represent the basis<br>
<br>
&nbsp; &nbsp;Example: &nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &gt;&gt;
mvPolynMonomBasis([3;2])<br>
<br>
</span><span style="font-family: Courier New;">&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="font-family: Courier New;">ans =<br>
<br>
</span><span style="font-family: Courier New;">&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="font-family: Courier New;">&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;
1&nbsp;&nbsp;&nbsp;&nbsp;
2&nbsp;&nbsp;&nbsp;&nbsp;
3&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;
1&nbsp;&nbsp;&nbsp;&nbsp;
2&nbsp;&nbsp;&nbsp;&nbsp;
3&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;
1&nbsp;&nbsp;&nbsp;&nbsp;
2&nbsp;&nbsp;&nbsp;&nbsp; 3<br>
</span><span style="font-family: Courier New;">&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="font-family: Courier New;">&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;
1&nbsp;&nbsp;&nbsp;&nbsp;
1&nbsp;&nbsp;&nbsp;&nbsp;
1&nbsp;&nbsp;&nbsp;&nbsp;
1&nbsp;&nbsp;&nbsp;&nbsp;
2&nbsp;&nbsp;&nbsp;&nbsp;
2&nbsp;&nbsp;&nbsp;&nbsp;
2&nbsp;&nbsp;&nbsp;&nbsp; 2<br>
&nbsp;</span><span style="font-family: Courier New;">&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="font-family: Courier New;">&nbsp;&nbsp;&nbsp;
1&nbsp;&nbsp;&nbsp;&nbsp;
1&nbsp;&nbsp;&nbsp;&nbsp;
1&nbsp;&nbsp;&nbsp;&nbsp;
1&nbsp;&nbsp;&nbsp;&nbsp;
1&nbsp;&nbsp;&nbsp;&nbsp;
1&nbsp;&nbsp;&nbsp;&nbsp;
1&nbsp;&nbsp;&nbsp;&nbsp;
1&nbsp;&nbsp;&nbsp;&nbsp;
1&nbsp;&nbsp;&nbsp;&nbsp;
1&nbsp;&nbsp;&nbsp;&nbsp;
1&nbsp;&nbsp;&nbsp;&nbsp; 1<br>
</span><br>
<span style="font-family: Courier New;"><br>
</span><b><font face="Agency FB" size="5"><a name="mvPolynProject"></a>mvPolynProject<br>
</font></b><br>
<span style="font-family: Courier New;">&nbsp;&nbsp;
Project an m-variate polynomial to an n-variate polynomial<br>
&nbsp;&nbsp;&nbsp;&nbsp; using given values on the m-n
variables<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp; syntax:&nbsp; G =
mvPolynProjection(F, x, ix)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; input:&nbsp; F
--- a multivariate polynomial in coef. matrix<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
x --- a vector of m-n values to be used for projection<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ix --- a vector of indices of the m-n variables<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp; output:&nbsp; G --- the
projected polynomial<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp; Example:&nbsp; To project a
polynomial F(x1,x2,x3,x4) to F(x1,1.6,x2,6.8):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt; G = mvPolynProject(F,[1.6,6,8],[2,4])<br>
<br>
</span><b><font face="Agency FB" size="5"><a name="mvPolynSort"></a>mvPolynSort<br>
</font></b><br>
<span style="font-family: Courier New;">&nbsp;&nbsp; Sort the terms of a multivariate polynomial f according to <br>&nbsp;&nbsp; the lexicographical order, and combine the like terms<br>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp; Syntax:&nbsp; &gt;&gt; G = mvPolynSort(F)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt;&gt; G = mvPolynSort(F, tord)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt;&gt; [G,idg] = mvPolynSort(F)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt;&gt; [G,idg] = mvPolynSort(F, tord)<br>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp; Input:&nbsp;&nbsp; F -- (matrix) multivariate polynomial in coeff. matrix<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tord -- (string, optional) 'lex' or 'grlex', term order type<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
The default is 'lex' if not provided<br>&nbsp;<br>&nbsp;&nbsp;&nbsp; Output:&nbsp;&nbsp; G --- (matrix) sorted coeff. matrix of the input polynomial <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; idg --- (vector) the indices of G terms<br>&nbsp;<br>&nbsp;&nbsp;&nbsp; Examples:<br>&nbsp;<br>&nbsp;&nbsp;&nbsp; &gt;&gt; F <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; F =<br>&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;
4&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp;
3&nbsp;&nbsp;&nbsp;&nbsp; 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;
1&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp; 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;
1&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp; 2<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
8&nbsp;&nbsp;&nbsp;&nbsp; 7&nbsp;&nbsp;&nbsp;
-7&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;
4&nbsp;&nbsp;&nbsp; -5<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; &gt;&gt; [g,idg] = mvPolynSort(F)<br>&nbsp;<br>&nbsp;&nbsp;&nbsp; G =<br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp; 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp; 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp; 2<br>&nbsp;&nbsp;&nbsp;&nbsp; 15&nbsp;&nbsp;&nbsp;&nbsp; 6&nbsp;&nbsp;&nbsp; -7&nbsp;&nbsp;&nbsp; -5<br>&nbsp;<br>&nbsp;&nbsp;&nbsp; idg =<br>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp; 20&nbsp;&nbsp;&nbsp; 26<br>&nbsp;<br>&nbsp;&nbsp;&nbsp; &gt;&gt; [G,idg] = mvPolynSort(F,'grlex')<br>&nbsp;<br>&nbsp;&nbsp;&nbsp; G =<br>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; 4<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp; 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp; 1<br>&nbsp;&nbsp;&nbsp;&nbsp; 15&nbsp;&nbsp;&nbsp;&nbsp; 6&nbsp;&nbsp;&nbsp; -5&nbsp;&nbsp;&nbsp; -7<br>&nbsp;<br>&nbsp;&nbsp;&nbsp; idg =<br>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp; 11&nbsp;&nbsp;&nbsp; 19&nbsp;&nbsp;&nbsp; 61<br>
<br>
</span><b><font face="Agency FB" size="5"><a name="mvGCDfixedDegree"></a>mvGCDfixedDegree<br>
</font></b><br>
<span style="font-family: Courier New;">&nbsp;
mvGCDfixedDegree computes the nearest greatest common divisor of a <br>
&nbsp; multivariate polynomial pair (F,G) with a fixed GCD degree.
The code is <br>
&nbsp; optimized under the assumption that&nbsp; F, G and the
GCD triplet are sparse <br>
&nbsp; fewnomials<br>
&nbsp;<br>
&nbsp; Syntax:&nbsp;&nbsp; &gt;&gt;
[U,V,W,res,cond] = mvPolynGCD(f,g,gcddeg) <br>
&nbsp;<br>
&nbsp; Input&nbsp;&nbsp; F, G -- the polynomial pairs as
coefficient matrices <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
gcddeg -- the tuple degree of the GCD, if known<br>
&nbsp;<br>
&nbsp; Output&nbsp;&nbsp;&nbsp;&nbsp; u,v,w -- the
NGCD triplet such that <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
u*v approximates f, u*w approximates g<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
res -- the (weighted) residual<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
cond -- the AGCD condition number<br>
&nbsp;<br>
&nbsp; Example:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt; F<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; F =<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;
2&nbsp;&nbsp;&nbsp;&nbsp;
1&nbsp;&nbsp;&nbsp;&nbsp; 3<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;
1&nbsp;&nbsp;&nbsp;&nbsp;
1&nbsp;&nbsp;&nbsp;&nbsp; 2<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;
3&nbsp;&nbsp;&nbsp;&nbsp; 3<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
3&nbsp;&nbsp;&nbsp;
-6&nbsp;&nbsp;&nbsp;&nbsp;
1&nbsp;&nbsp;&nbsp; -2<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt; G<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; G =<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;
1&nbsp;&nbsp;&nbsp;&nbsp;
1&nbsp;&nbsp;&nbsp;&nbsp; 2<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;
1&nbsp;&nbsp;&nbsp;&nbsp; 1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;
2&nbsp;&nbsp;&nbsp;&nbsp;
3&nbsp;&nbsp;&nbsp;&nbsp; 5<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
3&nbsp;&nbsp;&nbsp;&nbsp;
9&nbsp;&nbsp;&nbsp;&nbsp;
1&nbsp;&nbsp;&nbsp;&nbsp; 3<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;&gt; [u,v,w,res,cond] = mvGCDfixedDegree(F,G,[1,1,3])<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; u =<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp; 1.0000<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp; 1.0000<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp; 3.0000<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-11.6190&nbsp;&nbsp; -3.8730<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v =<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp; 2.0000<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp; 1.0000<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-0.2582&nbsp;&nbsp;&nbsp; 0.5164<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; w =<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp; 1.0000<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp; 2.0000<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-0.2582&nbsp;&nbsp; -0.7746<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res =<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
3.0461e-034<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cond =<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0.8969<br><br><br></span><b><font face="Agency FB" size="5"><big><a name="GrlexMonomialIndex"></a>GrlexMonomialIndex</big><br>
</font></b><br>
<span style="font-family: Courier New;">&nbsp;
&nbsp;Find the index of a given monomial in the graded lexicographical order<br>&nbsp;<br>&nbsp;&nbsp; Syntax: &gt;&gt; idx = GrlexMonomialIndex(m)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt;&gt; idx = GrlexMonomialIndex(m,d)<br>&nbsp;<br>&nbsp;&nbsp; Input&nbsp; m -- (vector) the exponents of the monomial<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(e.g. [3;1;2] represents x^3*y*z^2)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d -- (optional) total degree of the monomial<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Case 1: If d is not provided, the output index is the <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
location of the monomial in all possible terms<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Case 2: If d is provided, the output index is the location<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
of the monomial of degree d<br>&nbsp;<br>&nbsp; Output&nbsp; idx -- the index of the monomial<br>&nbsp;<br>&nbsp; Example:&nbsp; <br>&nbsp;&nbsp; &gt;&gt; GrlexMonomialIndex([2;0;1;1])<br>&nbsp;&nbsp;&nbsp;&nbsp; ans =<br>&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 45<br>&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp; &gt;&gt; GrlexMonomialIndex([2;0;1;1],4)<br>&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp; ans =<br>&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10</span><span style="font-family: Courier New;"><br><br><br><br></span><b><font face="Agency FB" size="5"><big><a name="GrlexNextMonomial"></a>GrlexNextMonomial</big><br>
</font></b><br>
<span style="font-family: Courier New;">&nbsp;
&nbsp;Find the next monomial in graded lexicographical order<br>&nbsp;<br>&nbsp;&nbsp; Syntax:&nbsp; &gt;&gt; M1 = GrlexNextMonomial(M0,n)<br>&nbsp;<br>&nbsp;&nbsp; Input:&nbsp;&nbsp; M0 -- (vector) exponents of a monomial<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(e.g. [3;1;2] represents x^3*y*z^2)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n -- (integer) number of variables<br>&nbsp;<br>&nbsp;&nbsp; Output:&nbsp; M1 -- (vector) exponents of the next monomial<br>&nbsp;</span><span style="font-family: Courier New;">&nbsp;</span></li></ul><b><font face="Agency FB" size="5"><a name="LinearSolve"></a><big>LinearSolve</big></font></b><big><b><font face="Agency FB" size="5"><big><br>
</big></font></b></big><span style="font-family: Courier New;"><br>&nbsp;&nbsp; Solve for the general numerical solution of <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (i)&nbsp; matrix-vector equation&nbsp;&nbsp; A*z = b&nbsp; for z = z0+Kernel(A)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (ii) linear operator equation&nbsp;&nbsp;&nbsp; L(z) = b&nbsp; for z = z0+Kernel(L)<br>&nbsp;&nbsp; within an error tolerance tol, where z0 is the minimum norm solution<br>&nbsp;&nbsp; and the kernel is the numerical kernle within the error tolerance tol<br>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp; Syntax for solving A*z = b (within error tolerance tol)&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp; &gt;&gt; [z, K, cnd, res] = LinearSolve(A, b)<br>&nbsp;&nbsp;&nbsp;&nbsp; &gt;&gt; [z, K, cnd, res] = LinearSolve(A, b, tol)&nbsp; <br>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp; syntax for solving L(z) = b (within error tolerance tol)<br>&nbsp;&nbsp;&nbsp;&nbsp; &gt;&gt; [z, K, cnd, res] = LinearSolve({L, Domain, para}, b)<br>&nbsp;&nbsp;&nbsp;&nbsp; &gt;&gt; [z, K, cnd, res] = LinearSolve({L, Domain, para}, b, tol)<br>&nbsp;&nbsp;&nbsp;&nbsp; &gt;&gt; [z, K, cnd, res] = LinearSolve({L, Domain, para, r}, b)<br>&nbsp;&nbsp;&nbsp;&nbsp; &gt;&gt; [z, K, cnd, res] = LinearSolve({L, Domain, para, r}, b, tol)<br>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp; Input (case i: Matrix-vector equation A*z = b): <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
A, b&nbsp; -- coefficient matrix and right-side vector in A*z=b<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tol&nbsp; -- error tolerance<br>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp; Input (case ii: Linear operator equation L(z) = b):&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
L&nbsp; -- Matlab function handle for calculating the linear <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
transformation with syntax &gt;&gt; L(X1,...,Xm,Q1,...,Qk) <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
where X1,...,Xm and Q1,...,Qk are variables and<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
parameters of L respectively. Each one of X1,...,Xm is <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(i) a matrix (including vector), or<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(ii) a polynomial<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
to be transformed by L.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
The remaining parameters Q1,...,Qk must be <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
provided as cell entries for para.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
If the codomain is a product space, the output of the<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
function L must be a cell array<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Domain&nbsp; -- domain of the linear transformation L represented by<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(i) an mxn matrix of 0' and 1's representing<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0 entries and variable entries respectively, or<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(ii) a polynomial with variable coefficients being <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
nonzero, or<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(iii) a cell array of matrices in (i) and/or (ii)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
assuming the domain is a product of matrix spaces and<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
polynomial spaces<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; para&nbsp; -- (cell) parameters needed for running L<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
**** L must run with &gt;&gt; L(Domain{:},para{:}) ***<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
r&nbsp; -- (integer, optional) if provided, the rank-r TSVD<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
solution and kernel is computed (In other words, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
substitute L and b with rank-r projections)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
b&nbsp; -- (matrix, polynomial or cell) The right-hand side of<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
the equation L(z) = b, must be in the codomain <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
of L<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tol -- (numeric) error tolerance (&lt; 1),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
or r = tol &gt; 1 indicating the rank-r projection of<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
the linear transformation is used<br>&nbsp;<br>&nbsp;&nbsp;&nbsp; Output:&nbsp;&nbsp; z -- the minimum norm solution so that ||L(z)-b|| is minimized<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
K -- an orthonormal basis for the kernel {y | L(y) = 0}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cnd -- condition number of the representation matrix.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
res -- (vector) the residuals of ||L(Z)-b||,||L(K{1}||,...||L(K{n}||</span>&nbsp;<ul>
</ul>
<br>
<br>
</body></html>